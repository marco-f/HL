<!-- /HTML/main.html -->
<!DOCTYPE html>
<html xml:lang="en" lang="en">
        <head>
                <!-- Meta tags to prevent caching -->
                <meta http-equiv="cache-control" content="max-age=0">
                <meta http-equiv="cache-control" content="no-cache">
                <meta http-equiv="expires" content="-1">
                <meta http-equiv="expires" content="Tue, 01 Jan 1980 11:00:00 GMT">
                <meta http-equiv="pragma" content="no-cache">
                <meta charset="UTF-8">

                <title>HobbyLaser!</title>


                <!-- favicon -->
                <link rel="icon" type="image/png" href="../IMG/lsr.svg">

                <link rel="stylesheet" href="https://necolas.github.io/normalize.css/8.0.1/normalize.css">

                <!-- style -->    
                <link rel="stylesheet" href="../CSS/drawing.css">
                <link rel="stylesheet" href="../CSS/jquery.css">

                <!-- third parties -->
                <script src="../JS/src/jquery.js"></script>
                <script src="../JS/src/jquery-ui.js"></script>
                <script src="../JS/src/fabric.js"></script>               
                <script src="../JS/ace/ace.js"></script>                
                <script src="../JS/src/clipper.js"></script>         
                <script src="../JS/src/opentype.js"></script> 
                <script src="../JS/src/potrace.js"></script>
                <script src="../JS/src/polyfill.js"></script>
                <script src="../JS/src/drawing.js"></script>
                <script src="../JS/src/ruler.js"></script>
                <script src="../JS/src/dxf.js"></script>

                <!-- three.js -->
                <script src="../JS/three/three.js"></script>
                <script src="../JS/three/gcode-model.js"></script>
                <script src="../JS/three/OrbitControls.js"></script>
        </head>

        <style>
                * {box-sizing: border-box}

                html, body {width:100%; height:auto; margin:0; color:#fff}        
                .hidden-cursor {cursor: none} 
                @font-face {
                        font-family: test-family;
                        src: url("FONT/Roboto-Black.ttf")
                }   
         
                ::-webkit-scrollbar {width:7px}
                ::-webkit-scrollbar-thumb {
                        background:rgba(0,0,0,0);
                        border-radius: 4px; cursor:pointer
                }

                ::selection {color:white; background: rgb(25,25,25)}  

                .center_H{position:absolute; text-align: center}  
                
                .bs {
                        position:absolute;
                        width: 100px; height: 20px;
                        color:#fff; font-size:10px; 
                        border:none; background:none; outline:none
                }
                .btImg {
                        position:absolute;
                        width: 100px; height: 20px;
                        color:#fff; cursor:pointer; font-size:10px;
                        border: none; background:none; outline:none
                }
                .btImg:hover {color:#2f81f7}                   

                #_2D {
                        overflow-x:hidden;
                        position: absolute;
                        background:#080808;
                        top: 20px; left: 0; right: 0;
                        width: 100%; height: 100%; 
                }

                #n_Line {
                        outline:none;user-select: none;
                        position:absolute; resize:none;
                        font-size:18px; line-height:0.72; 
                        border: 0; text-align: left;
                        overflow:hidden; width:30px;
                        color:gray;top:35px; height:100%; 
                        background:transparent}
                #n_Line:focus-visible,

                #editor {position:absolute;bottom:0; top:10px; border: 0;
                        left:0; right:0; line-height: 1.2;background:#050505}
                .ace_editor *{font-size: 12px !important; color:gray}
                .ace_editor {border: none !important}
                .ace_scrollbar {display: none !important}
                .ace_editor .ace_marker-layer .ace_selection {background:#202020}
                .ace_editor .ace_cursor {color: red}
                .ace_tooltip {display: none !important} 
                #TA.closed {transform: translateX(100%)}                   

                a {color:gray}
                                 
                #progress-container {
                        position:absolute;     
                        width: 100%; bottom:0px;
                        background-color:transparent;
                        height: 2px; margin-top: 0px;
                }
                #progress-bar {
                        width: 0%; height: 100%;
                        background-color: #2f81f7;
                }

                .fade_2 {opacity: 0; transition: opacity 2s ease-in-out}

                #crud-wrapper {
                        position: absolute;
                        width:450px; top:50px; right:0px; left:30px
                }
                #crud {
                        top:30px; left:20px;
                        flex-direction: column;            
                        padding: 2px 2px 2px 0px;            
                        display:flex; max-width:440px;    
                        position:relative; overflow-y:auto;
                }
                #fileList {
                        width: 100%;
                        list-style: none;
                        padding: 0; margin: 0;
                }
                #fileList li {margin-bottom:10px;
                        font-size:12px;
                        display: flex;
                        align-items: center;
                        padding: 2px; width: 100%;
                        justify-content: space-between;    
                }
                .button-container {
                        display: flex; gap: 10px;
                        justify-content: flex-end;    
                }

                #svgCont .custom-svg {
                        width: 300px; height: 200px;
                        border: 1px solid #3c3c3c;
                        box-sizing: border-box;
                        position: absolute;
                        padding: 10; z-index:500; top: 100px; left:100px
                }

                .alert-box {
                        z-index: 1000; display: flex;width:60%;
                        position: fixed; top: 40%; left: 50%; top:50%;
                        transform: translate(-50%, -50%);
                        background: #101010; padding: 20px;
                        border: 1px solid #444; border-radius: 8px;
                        align-items: center;  text-align: center;
                }
                .alert-content {
                        font-size:14px; font-weight:bold; width:100%;
                }
                .alert-img {
                        position: relative;
                        background: transparent;
                        height: 120px; width: 100px;
                }
                .disclaimer-text {
                        font-size: 12px; width: 80%;
                        margin: 0 auto; text-align: center;
                }
                .btAlert {
                        cursor: pointer; appearance: none; outline: 0;
                        border:1px solid gray; width:177px; background:#101010;
                        text-align: center; height: 25px; color:gray;
                        font-weight: 250; font-size: 12px; border-radius:15px;
                        margin: 0; position: relative;
                }                        
                .btAlert::before {
                        content: ""; position: absolute; left: 0;
                        top: 0; width: 100%; height: 100%;
                        border-radius: 30px; border: 1px solid white;
                        box-sizing: border-box; clip-path: inset(0 100% 0 0);
                        transition: clip-path 0.3s ease-in;color:#fff
                }
                .btAlert:hover::before {clip-path: inset(0 0 0 0)}
                .btAlert:hover {background: #050505; color:#fff}
                .btAlert:focus {
                        background: #0a0a0a;
                        color: #2f81f7;
                        //box-shadow: 0 0 0 2px #ffffff44;
                }
                .btAlert:focus::before {
                        clip-path: inset(0 0 0 0);
                }

                
                /*@media (max-width: 1400px) {
                        #panel {
                                left: 50px;  right: 50px;
                        }
                }
                @media (max-width: 1200px) {
                        #panel {
                                left: 20px;  right: 20px;
                        }
                }
                @media (max-width: 800px) {
                        #panel {
                                align-items: center;
                                flex-direction: column;
                                height: auto; display: flex; 
                                left: 5vw; right: 5vw; padding: 10px;
                        }
                        #preview {
                                width: 100%; height: auto; margin: 10px 0;    
                        }
                        #first {
                                flex-direction: column;
                        }
                        .right-column { 
                                width: 100%;  margin-left: 0; margin-top: 10px;
                        }
                        #third {
                                width: 100%; height: 150px; margin: 10px 0;
                        }
                }*/

                .panel {
                        height: 60vh; aspect-ratio: 1 / 1; background: #101010;
                        border: 1px solid #3c3c3c; flex-shrink: 0; z-index:500; 
                }              

                #tbScroll {
                        overflow: auto; max-height: calc(100% - 20px) !important; 
                }
                table {
                        z-index:500;
                        max-width: 100%; font-size: 12px;
                        border-collapse: collapse;
                        max-height: 100% !important; 
                }
                th {background: transparent; padding-left: 10px; font-size: 12px}
                #td:first-child {padding-right: 30px}

                .close-btn {
                        font-weight: bold; font-size: 14px;
                        width:30px; height:30px; background-color:#080808;
                        position:absolute; top:10px; right:10px; z-index:500;
                        text-align:center; line-height:26px; cursor: pointer;        
                        border:2px solid #3c3c3c; color:white; border-radius:50%
                }
                .close-btn:hover {background-color: #1a1a1a}

                .btRD {
                        display: flex;align-items: center; 
                        justify-content:center;color: gray;        
                        cursor: pointer; border-radius: 50%;
                        border: 1px solid #3c3c3c; font-size: 15px; outline:none;       
                        background:#080808; width:16px; height:16px; padding-bottom:2px           
                }
                .btRD:focus {outline:none; color:white}
                .btRD:disabled {
                        opacity: 0.4; cursor: not-allowed;    
                        color: #888; background: #222; border-color: #555
                }

                .btTool {margin-left: 0px;
                        text-align: center;  color: gray;        
                        cursor: pointer; border-radius: 50px;
                        border: 1px solid #3c3c3c; font-size: 10px;        
                        background:#080808; width:80px; padding:5px;              
                }
                .btTool:hover {color:white}                             
        </style>
                                                              
        <body>   
                <!-- html HEAD -->
                <div id="head" style="background:#080808;
                        z-index:9; border-bottom:0px solid #3c3c3c;
                        width:100%; height:40px; position:fixed;
                        top:0px; border-top:0px solid #11e1e">

                        <div class="bs" style="top:13px; width:200px; left:30px" onclick="">
                                <img src="../IMG/HLB.png" width="200px" height="16px"/>
                        </div>

                        <button class="btImg" style="cursor:pointer; font-size:10px;
                                top:10px; right:100px" onclick="window.location.reload(true)">refresh</button>
                        <!-- UserGUIDE -->
                        <button class="btImg" style="cursor: pointer; font-size:10px; top:10px; right:20px"
                        onclick="window.open('https://github.com/marco-f/HL/wiki/Home', '_blank')">
                                <img src="../IMG/GH.svg" width="17px" style="cursor:pointer"/>
                        </button>
                                               
                        <input style="display:none" type="file" id="input"/>

                        <div id="progress-container">
                                <div id="progress-bar"></div>
                        </div>                      
                </div>
                                  
                <div id="_2D">
                        <script>
                                $("#_2D").load("../HTML/rend.html")
                        </script>
                </div>

                <button style="position:fixed; z-index:100; left:1px; top:40px; width:18px; height:20px; border:0; cursor:pointer;
                        background:#101010; border-right:1px solid #888; border-bottom:1px solid #888;"
                        onclick="createInteractiveGuide()"></button>

                <div id="horizontalLabel" class="label"></div>
                <div id="verticalLabel" class="label"></div>



                <div id="OV" style="z-index:400; border:0px solid #3c3c3c; display:none;
                        position:fixed; width:101%; height:100%; left:0; top:40px; background:transparent">
                </div>                            


                <!-- editor (scriptArea) -->
                <div id="TA" style="border-left:1px solid #3c3c3c; z-index:150; resize: horizontal; cursor: ew-resize; transform: translateX(100%);
                        position: fixed; width: 40%; height:100%; right: 0; top: 60px; background: #050505; transition: transform 0.5s ease">

                        <!-- Textarea for line indicators (read-only) -->
                        <textarea id="n_Line" style="right: 0px; top: 10px; height: calc(100% - 150px); overflow: hidden" wrap="off" readonly></textarea>

                        <!-- Div container for the Ace editor -->
                        <div id="editor" class="language-javascript" style="position: absolute; color: white; width: calc(50% - 50px); height: calc(100% - 150px)"></div>

                        <script>
                                var tooltip = document.getElementById("textTooltip")               
                                var cE = document.getElementById('editor');
                                cE.addEventListener("contextmenu", function(e) {
                                        e.stopPropagation()
                                })

                                var nL = document.getElementById('n_Line')
                                nL.style.fontSize = '18px'
                                nL.style.pointerEvents = "none"

                                var editor = ace.edit("editor")
                                var taClosed = true

                                function updateLayout() {
                                        var taWidth = $("#TA").width()
                                        var editorWidth = taWidth - 30
                                        var windowHeight = $(window).height()
                                        var footerHeight = $("#footer").height()
                                        var editorHeight = windowHeight - footerHeight - 90 ///////////////////////////////////////////////////////////////

                                        $("#editor").width(editorWidth).height(editorHeight)
                                        $("#n_Line").height(editorHeight)

                                        if (typeof editor.resize === 'function') {
                                                editor.resize();
                                        }

                                        if (taWidth <= 50) {$("#n_Line").hide()}
                                        else {$("#n_Line").show()}
                                }

                                function TAClose() {
                                        if (!taClosed) {
                                                $("#TA").css("transform", "translateX(100%)");
                                                taClosed = true;
                                        }
                                }

                                function TAOpen() {
                                        if (taClosed) {
                                                $("#TA").css("transform", "translateX(0)");
                                                taClosed = false;
                                                setTimeout(updateLayout, 500);
                                        }
                                }

                                $("#TA").resizable({
                                        handles: 'w', minWidth: 0,
                                        maxWidth: $(window).width() - 250,
                                        resize: function(event, ui) {
                                                var newWidth = ui.size.width
                                                var editorWidth = newWidth - 30
                                                $("#editor").width(editorWidth)
                                                if (typeof editor.resize === 'function') {
                                                        editor.resize()
                                                }
                                                if (newWidth <= 50){$("#n_Line").hide()}
                                                else {$("#n_Line").show()}
                                        },
                                        stop: function(event, ui){
                                                var newWidth = ui.size.width;
                                                if (newWidth <= 50 && !taClosed) {
                                                        TAClose();
                                                }
                                        }
                                })

                                $(window).on('resize', updateLayout)

                                editor.setTheme("ace/theme/pastel_on_dark")
                                editor.session.setMode("ace/mode/javascript")
                                editor.getSession().setUseWrapMode(true)
                                editor.getSession().setWrapLimitRange(null, null)
                                editor.setOption("scrollPastEnd", 0)
                                editor.setOption("showGutterTooltip", false)
                                editor.setBehavioursEnabled(false)
                                editor.setOptions({
                                        fontFamily: "'Courier New', monospace"
                                })
                                editor.getSession().setUseWorker(false)
                                editor.session.clearAnnotations()

                                editor.getSession().on('change', function() {
                                        end_line()
                                })

                                editor.setValue(`//uncomment and after ctrl + enter
function simpleGear(numberOfTeeth, radius, heightOfTooth){
        var paths = [[]];    
        var centerX = 30; 
        var centerY = 30;
        var radiusMinusTeeth = radius - heightOfTooth;

        var distancesOfVerticesFromCenter = [
                radius, radius,
                radiusMinusTeeth,
                radiusMinusTeeth,
        ];
        var verticesPerTooth = distancesOfVerticesFromCenter.length;
        var numberOfVertices = numberOfTeeth * verticesPerTooth;

        for (var v = 0; v < numberOfVertices; v++) {
                var angleInRadians = (Math.PI * 2 * v) / numberOfVertices;
                var distanceOfVertexFromCenter = distancesOfVerticesFromCenter[v % verticesPerTooth];

                var drawPosX = centerX + distanceOfVertexFromCenter * Math.cos(angleInRadians);
                var drawPosY = centerY + distanceOfVertexFromCenter * Math.sin(angleInRadians);

                paths[0].push({ X: drawPosX, Y: drawPosY });        
        }
        paths[0].push(paths[0][0]); return use(paths);
}
simpleGear(15, 20, 4).nc
//POLYLINE("M10 10 L40 10 L40 40 L10 40 L10 10 Z").tab(2,4).nc
`)
                                editor.clearSelection()
                                editor.moveCursorTo(0, 0);

                                function end_line() {
                                        var totalLines = editor.getSession().getLength(),
                                                outarr = [];
                                        for (var x = 0; x < totalLines; x++) {
                                                outarr[x] = '↩';
                                        }
                                        nL.value = outarr.join('\n')
                                }

                                function appToEdt(text) {
                                        var session = editor.getSession()
                                        var oldText = session.getValue()
                                        session.setValue(oldText + text)
                                }

                                function autoScroll() {
                                        var session = editor.getSession()
                                        var length = session.getLength()
                                        editor.scrollToLine(length, true, true, function() {})
                                }

                                editor.getSession().on('change', function() {
                                        autoScroll()
                                })

                                function remToEdt(searchString) {
                                        var content = editor.getValue();
                                        var regex = new RegExp(searchString + "\\([^)]*\\)", "g")
                                        var lines = content.split("\n"),
                                                modifiedLine = -1;
                                        for (var i = 0; i < lines.length; i++) {
                                                if (regex.test(lines[i])) {
                                                        modifiedLine = i; break
                                                }
                                        }
                                        var updatedContent = content.replace(regex, "")
                                        editor.setValue(updatedContent, -1)
                                        if (modifiedLine !== -1) {
                                                editor.gotoLine(modifiedLine + 2, 0, true)
                                        }; editor.focus()
                                }

                                editor.commands.addCommand({
                                        name: "executeCommand",
                                        bindKey: {win: "Ctrl-Enter", mac: "Command-Enter"},
                                        exec: function(editor) {
                                                var command = editor.getValue().trim()
                                                try { runSCRIPT() }
                                                catch (e){ console.error("error", e) }
                                        }
                                })
   

                                var runSCRIPT = () => {
                                        //try {
                                                clearCNVS()
                                                var userCode = editor.getValue()
                                                var content = edtContent(userCode)
                                                if (cancBool == true){
                                                        canvas.remove(imgInstance)
                                                }
                                                pts = eval(content);
                                                tempGuideLines = interactiveGuides
                                                for (var i = 0; i < tempGuideLines.length; i++){
                                                        var guidePair = tempGuideLines[i]
                                                        canvas.add(guidePair.verticalLine).bringToFront()                                        
                                                        canvas.add(guidePair.horizontalLine).bringToFront()
                                                        canvas.add(guidePair.intersectionCircle).bringToFront()                                       
                                                }
                                                cancBool = false
                                        //} catch(error) {console.error(error)}
                                }
                        </script>
                </div>

                <!-- Footer container (acts as a control panel and log area) -->
                <div id="footer" style="z-index:300; cursor:default; font-family:'Monospace'; font-size:9px; overflow: hidden; left:0;
                position:fixed; bottom:0px; width:100%; height:200px; background:#080808; border-top:2px solid #000; color:#ffffff">

                        <!-- Console log display area -->
                        <div id="cnsLog" class="center_H" style="position: absolute; overflow-x: hidden; background:#050505; line-height:1.5;
                        font-size:10px; border-top:1px solid #3c3c3c; color:gray; top:0px; left:0px; width: 100%; height: calc(100% - 25px)">
                                <!--p id="cnsl" style="position:absolute; top:-5px; right:20px; font-size:10px">>_ ConsoleLog</p-->
                        </div>

                        <!-- JavaScript code -->
                        <script>
                                function ftr() {
                                        var previousHeight = 80

                                        function updateLayout() {
                                                var footerHeight = $("#footer").height()
                                                var windowHeight = $(window).height()
                                                var desiredH = windowHeight - footerHeight + 20
                                                $("#_2D").height(desiredH);
                                        }

                                        FTRClose = function () {
                                                var currentHeight = $("#footer").height()
                                                if (currentHeight > 80) {
                                                        previousHeight = currentHeight
                                                        $("#footer").height(120)
                                                        $("#footer").css('top', 'calc(100% - 80px)')
                                                        updateLayout()
                                                }
                                        }

                                        FTROpen = function () {
                                                $("#footer").height(previousHeight)
                                                $("#footer").css('height', `80px)`)
                                                updateLayout()
                                        }

                                        $("#footer").resizable({
                                                handles: 'n',
                                                minHeight: 80,
                                                maxHeight: 600,
                                                resize: updateLayout
                                        });

                                        $(window).on('resize', updateLayout)
                                        $(window).trigger('resize')                                
                                }; ftr()

                                var cnsLog = document.getElementById('cnsLog')
                                /*function logging() {
                                        var MAX_LOG_LINES = 200
                                        var logBuffer = []
                                        var bufferFlushInterval = 200  // ms

                                        function customLog(type, color, ...args) {
                                                var  t = new Date()
                                                var  hh = String(t.getHours()).padStart(2, '0')
                                                var  mm = String(t.getMinutes()).padStart(2, '0')
                                                var  ss = String(t.getSeconds()).padStart(2, '0')
                                                var  time = `${hh}:${mm}:${ss}&nbsp;&nbsp;`

                                                var output = ''
                                                args.forEach(arg => {
                                                        output += `<span style="color:${color}">`
                                                        if (arg instanceof Error) {
                                                                output += `<b>${arg.name}: ${arg.message}</b><br>`
                                                        } else if (typeof arg === 'object') {
                                                                output += JSON.stringify(arg, null, 2)
                                                        } else {
                                                                output += arg
                                                        }
                                                        output += '</span>&nbsp;'
                                                })

                                                var html = `<br>
                                                        <span style="color: rgb(60,60,60); line-height:0.2">${"&nbsp;&nbsp;" + time}</span>
                                                        <span style="color: gray; font-weight:bold; line-height:0.2">${"&nbsp;&nbsp;" + type.toUpperCase()}</span>
                                                        <span style="color: red; left:20; line-height:0.2"> >>> </span>
                                                        ${output}`

                                                logBuffer.push(html)
                                        }

                                        function flushLogBuffer() {
                                                if (logBuffer.length === 0) return
                                                var html = logBuffer.join('')
                                                cnsLog.insertAdjacentHTML('beforeend', html)
                                                cnsLog.scrollTop = cnsLog.scrollHeight
                                                logBuffer = []
                                        }

                                        function trimLogLines() {
                                                var children = cnsLog.children
                                                var excess = children.length - MAX_LOG_LINES
                                                for (var i = 0; i < excess; i++) {
                                                        cnsLog.removeChild(children[0])
                                                }
                                        }

                                        console.log = (...args) => customLog('log', '#73abfb', ...args)
                                        console.warn = (...args) => customLog('warn', '#c2c24c', ...args)
                                        console.info = (...args) => customLog('info', '#a7cafc', ...args)
                                        console.error = (...args) => customLog('error', '#b3d5e0', ...args)
                                        console.debug = (...args) => customLog('debug', '#ffffff', ...args)
                                        console.response = (...args) => customLog('response', '#808080', ...args)
                                        console.gcode = (msg, color = '#fff') => {customLog('gc', color, msg)}

                                        console.log('ready ...')
                                        setInterval(flushLogBuffer, bufferFlushInterval)
                                        setInterval(trimLogLines, bufferFlushInterval * 25)
                                }; logging()

                                var scrollTimeout
                                var observer = new MutationObserver(() => {
                                        if (scrollTimeout) clearTimeout(scrollTimeout)
                                        scrollTimeout = setTimeout(() => {
                                                cnsLog.scrollTop = cnsLog.scrollHeight
                                        }, 100)
                                }); observer.observe(cnsLog, {childList: true})*/

                                var objNumber = 0;
                                function addToConsole() {
                                        objNumber = canvas.getObjects().length - 1
                                        console.log("HL obj on canvas: " + objNumber)
                                }
                        </script>
                </div>

                <!-- Bottom fixed control bar -->
                <div id="srv" style="z-index:900; position:fixed; bottom:0px; width:100%; height:
                25px; left:0px; font-size:11px; background:#080808; border-top:1px solid #2f81f7">

                        <!-- Position indicators -->
                        <p id="mPos" style="position:fixed; color:gray; bottom:-7px; left: 20px; font-size:11px">pos (x:, y:)</p>
                        <p id="cPos" style="position:fixed; color:gray; bottom:-7px; left:200px; font-size:11px">pos (row:, col:)</p>
                        <p id="wa" style="position:fixed; color:gray; bottom:-7px; left:380px; font-size:11px">WorkArea (w:, h:)</p>
                        <p id="fps" style="position:fixed; color:gray; bottom:-7px; right:20px; width:70px; font-size:11px"></p>

                        <p style="position:fixed; color:gray; bottom:-7px; right:300px; width:70px; font-size:11px; cursor:pointer" onclick="TAOpen()">OpenTA</p>

                        <!-- Clear Log and Reset Swap buttons with onclick events -->
                        <p style="position:fixed; color:gray; bottom:-7px; right:100px; width:150px; font-size:11px; cursor:pointer"
                        onclick="cnsLog.innerHTML=''; console.log('ready ...')">< Clear Log ></p>

                        <script>
                                var pos = document.getElementById("mPos")
                                function mousePos(ev) {
                                        var dpi = window.devicePixelRatio * 96
                                        posX = (ev.clientX * (25.4 / dpi)).toFixed(0) - 5
                                        posY = (ev.clientY * (25.4 / dpi)).toFixed(0) - 15
                                        pos.innerHTML = 'mPos (x: ' + posX + ', y: ' + posY + ')'
                                }; document.addEventListener('mousemove', mousePos, false)

                                var cur = document.getElementById("cPos")
                                function cursorPos(ev) {
                                        var cursorPosition = editor.getCursorPosition()
                                        row = cursorPosition.row + 1
                                        col = cursorPosition.column
                                        cur.innerHTML = 'cPos (row: ' + row + ', col: ' + col + ')'
                                }; document.addEventListener('mousemove', cursorPos, false)

                                var wa = document.getElementById("wa")
                                function calculateWASize() {
                                        wa.innerHTML = 'WorkArea (w: ' + dWidth + ',h: ' + dHeight + ')'
                                }; calculateWASize()

                                var fpsElement = document.getElementById('fps')
                                var frame = 0, startTime = performance.now()
                                function calculateFPS() {
                                        frame++
                                        var now = performance.now();
                                        if (now - startTime > 1000) {
                                                var fps = (frame / ((now - startTime) / 1000)).toFixed(2)
                                                fpsElement.textContent = `${fps} fps`
                                                frame = 0; startTime = now
                                        }; requestAnimationFrame(calculateFPS)
                                }; calculateFPS()
                        </script>
                </div>

                <!-- GCode Section -->
                <div id="GCC" style="z-index:350; position:absolute; background:#101010; width:780px; height:330px; 
                left: 50%; top: 50%; transform: translate(-50%,-50%); border: 1px solid #3c3c3c; display:none">
                        <h3 style="text-align:center">< GCODE GENERATOR ></h3>
                        <!--button class="bs" style="top:20px; right:-20px; cursor:pointer" onclick="toggleGCconv()">X</button-->       
                               
                        <div class="buttons-container" style="top:70px; width:100%">
                                <div style="width:auto; height:auto; margin-left:10px; position:relative; display:flex; gap:6px">
                                        <span class="txtInp" style="background:transparent; border:0; cursor:default; width:50px; text-align:center">MODE</span>
                                        <button class="btRD" id="m_1" onclick="setMODE('m_1')">●</button> cutter
                                        <button class="btRD" id="m_2" onclick="setMODE('m_2')">●</button> infill                  
                                        <button class="btRD" id="m_3" onclick="setMODE('m_3')">●</button> image
                                </div>
                        </div>
                                          
                        <div id="t_1" class="buttons-container" style="top:120px">
                                <span class="txtInp" style="background:transparent; border:0; cursor:default; width:70px">min POWER(%)</span>
                                <input class="txtInp" type="text" id="_02" placeholder="set power" maxlength="4" value="0"/>

                                <span class="txtInp" style="background:transparent; border:0; cursor:default; width:50px;">max POWER(%)</span>
                                <input class="txtInp" type="text" id="_03" placeholder="set power" maxlength="4" value="255"/>

                                <span class="txtInp" style="background:transparent; border:0; cursor:default; width:50px">speed TRAVEL</span>
                                <input class="txtInp" type="text" id="_04" placeholder="radius" value="1000"/>

                                <span class="txtInp" style="background:transparent; border:0; cursor:default; width:50px;">speed LASER</span>
                                <input class="txtInp" type="text" id="_05" placeholder="radius" value="600"/>
                                          
                                <span class="txtInp" style="background:transparent; border:0; cursor:default; width:50px">n° PASS.</span>
                                <input class="txtInp" type="text" id="_06" placeholder="n° passes" value="1"/>
                        </div>
                        <div id="t_2" class="buttons-container" style="top:160px">
                                <span class="txtInp" style="background:transparent; border:0; cursor:default; width:70px">rowsPerMM</span>
                                <input class="txtInp" type="text" id="_07" placeholder="rows/mm" maxlength="4" value="1"/>

                                <span class="txtInp" style="background:transparent; border:0; cursor:default; width:50px">Z-AXIS</span>
                                <input class="txtInp" type="text" id="_08" placeholder="inc. Z" maxlength="4" value="0"/>

                                <span class="txtInp" style="background:transparent; border:0; cursor:default; width:50px">Z-MAX</span>
                                <input class="txtInp" type="text" id="_09" placeholder="inc. Z" maxlength="4" value="0"/>                                

                                <span class="txtInp" style="background:transparent; border:0; cursor:default; width:50px">&nbsp;air&nbsp;
                                ASSIST</span><input class="txtInp" type="text" id="_10" placeholder="set air" maxlength="4" value="0"/>
                               
                                <span class="txtInp" style="background:transparent; border:0; cursor:default; width:50px">Acc. (mm/s²)</span>
                                <input class="txtInp" type="text" id="_11" placeholder="inc. Z" maxlength="4" value="500"/>
                        </div>

                        <div id="t_3" class="buttons-container" style="top:220px; width:100%">
                                <div id="d_1" style="width:auto; height:auto; margin:0 auto; position:relative; display:flex; align-items:center; gap:6px">

                                
                                        <span class="txtInp" style="background:transparent; border:0; cursor:default; width:50px">toGCODE</span>
                                        <button class="btTool" onclick="obj2gc()">create</button>
                                </div>
                        </div>

                        <p class="bs" style="width:100%; top:290px; text-align:center">* set MODE cutter/infill (vector), image (raster)</p>                 
                               
                        <script>                       
                                var gcBool = false
                                function toggleGCconv() {
                                        if (!gcBool) {
                                                $('#GCC').show(); gcBool = true
                                                GCSenderHide(); updateButtons()
                                                setTimeout(function() {
                                                        mode = 'cutter'; document.getElementById("m_1").focus()
                                                }, 0)
                                        } else {$('#GCC').hide(); gcBool = false}
                                }

                                var mode = 'cutter'
                                var setMODE = function(activeId) {
                                        var button1 = document.getElementById('m_1')
                                        var button2 = document.getElementById('m_2')
                                        var button3 = document.getElementById('m_3')

                                        button1.blur(); button2.blur(); button3.blur()
                                        document.getElementById(activeId).focus()

                                        if (activeId === 'm_1') mode = 'cutter'
                                        else if (activeId === 'm_2') mode = 'engrave'
                                        else if (activeId === 'm_3') mode = 'image'

                                        updateButtons()
                                }

                                document.addEventListener('DOMContentLoaded', function() {
                                        updateButtons()
                                })

                                function updateButtons() {
                                        if (tabBool) {
                                                $('#m_2, #m_3').prop('disabled', true); return
                                        }

                                        if (mode == 'cutter' || mode == 'image') {
                                                document.getElementById('m_2').disabled = false
                                                document.getElementById('m_3').disabled = false
                                        } 
                                        else if (mode == 'engrave') {
                                                document.getElementById('m_2').disabled = false
                                                document.getElementById('m_3').disabled = false
                                        }
                                }


                                var GCSenderShow = function() {
                                        lines = 0
                                        progressBar.innerHTML = ''
                                        leftPanel.style.visibility = 'visible'
                                        centerPanel.style.visibility = 'visible'
                                        rightPanel.style.visibility = 'visible'
                                        var view3d = document.getElementById("3dView")
                                        view3d.style.display = "block"
                                        progressBar.style.width = "0%"

                                        abbBB = false; toggleGCconv()
                                }
                                var GCSenderHide = function() {
                                        $("#configArea").hide()
                                        leftPanel.style.visibility = 'hidden'
                                        centerPanel.style.visibility = 'hidden'
                                        rightPanel.style.visibility = 'hidden'
                                        var view3d = document.getElementById("3dView")
                                        view3d.style.display = "none"
                                        setTimeout(() => {
                                                progressBar.style.width = "0%"
                                                sentGCodeLines = 0; totalGCodeLines = 0
                                        }, 1000); isImageMode = false
                                }

                                var usedFileNames = []
                                function makeUniqueFlName(value) {
                                        var uniqueValue = value, counter = 1
                                        while (usedFileNames.includes(uniqueValue)) {
                                                uniqueValue = value + "_" + counter
                                                counter++
                                        }; return uniqueValue
                                }
                              
                                var isImageMode = false
                                function obj2gc() {
                                        if (mode === 'cutter') {
                                                isImageMode = false; svg2gc(md = 0)
                                        } else if (mode === 'engrave') {
                                                isImageMode = false; svg2gc(md = 1);
                                        } else if (mode === 'image') {
                                                isImageMode = true; img2gc();
                                        } else {
                                                throw new Error("mode must be 'image', 'cutter' or 'engrave'")
                                        }

                                        var content = editor.getValue()
                                        var updatedContent = content.replace(/obj2gc\([^)]*\)/g, "")
                                        editor.setValue(updatedContent, -1); editor.focus()
                                }

                                var bbGCode = ''
                                function getBoundingBoxFromGCode(gcode) {
                                        const lines = gcode.split(/\r?\n/)
                                        let lastX = 0, lastY = 0, lastZ = 0
                                        let lastPower = 0
                                        let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity

                                        for (const raw of lines) {
                                                let line = raw.split(';')[0] || ''
                                                line = line.trim()
                                                if (!line) continue

                                                const tokens = line.match(/[A-Za-z][^ \t]*/g) || []
                                                if (tokens.length === 0) continue

                                                const cmd = tokens[0].toUpperCase()
                                                if (!cmd) continue

                                                const args = {}
                                                for (let i = 1; i < tokens.length; i++) {
                                                        const t = tokens[i]
                                                        if (!t || t.length < 2) continue
                                                        const key = t[0].toUpperCase()
                                                        const num = parseFloat(t.substring(1))
                                                        if (Number.isNaN(num)) continue
                                                        args[key] = num
                                                }

                                                if (cmd === 'M3' || cmd === 'M03') {
                                                        if (args['S'] !== undefined) lastPower = args['S']
                                                        continue
                                                }
                                                if (cmd === 'M5' || cmd === 'M05') {
                                                        lastPower = 0
                                                        continue
                                                }
                                                if (args['S'] !== undefined) lastPower = args['S']

                                                let gnum = NaN
                                                if (cmd.startsWith('G')) {
                                                        gnum = parseInt(cmd.slice(1), 10)
                                                }

                                                if (!Number.isNaN(gnum) && (gnum === 0 || gnum === 1)) {
                                                        const newX = args['X'] !== undefined ? args['X'] : lastX
                                                        const newY = args['Y'] !== undefined ? args['Y'] : lastY
                                                        const newZ = args['Z'] !== undefined ? args['Z'] : lastZ

                                                        const isDraw = gnum === 1 && lastPower > 0
                                                        if (isDraw) {
                                                                minX = Math.min(minX, lastX, newX)
                                                                maxX = Math.max(maxX, lastX, newX)
                                                                minY = Math.min(minY, lastY, newY)
                                                                maxY = Math.max(maxY, lastY, newY)
                                                        }

                                                        lastX = newX
                                                        lastY = newY
                                                        lastZ = newZ
                                                }
                                        }

                                        if (!isFinite(minX)) return null
                                        return {minX, maxX, minY, maxY}
                                }
                                async function addBoundingBox(gcode) {
                                        const { minX, maxX, minY, maxY } = getBoundingBoxFromGCode(gcode)

                                        if (!isFinite(minX) || !isFinite(maxX) || !isFinite(minY) || !isFinite(maxY)) return

                                        const margin = 1
                                        const x1 = minX - margin
                                        const y1 = minY - margin
                                        const x2 = maxX + margin
                                        const y2 = maxY + margin
                                        bbGCode = ''
                                        bbGCode += '\n; start BB\n'
                                        bbGCode += `G0 X${x1.toFixed(2)} Y${y1.toFixed(2)}\n`
                                        bbGCode += 'M3 S0\n'
                                        bbGCode += `G1 X${x2.toFixed(2)} Y${y1.toFixed(2)} F1000\n`
                                        bbGCode += `G1 X${x2.toFixed(2)} Y${y2.toFixed(2)} F1000\n`
                                        bbGCode += `G1 X${x1.toFixed(2)} Y${y2.toFixed(2)} F1000\n`
                                        bbGCode += `G1 X${x1.toFixed(2)} Y${y1.toFixed(2)} F1000\n`
                                        bbGCode += 'M5\nG4 P1\n'
                                        bbGCode += '; end BB\n\n'

                                        console.log("bounding-box:", {x1, y1, x2, y2}); 
                                }
                                function prepareGCodeSettings(type) {
                                        var minPWR = parseInt($("#_02").val())
                                        var maxPWR = parseInt($("#_03").val())
                                        var speedTRVL = parseInt($("#_04").val())
                                        var speedLSR = parseInt($("#_05").val())
                                        var passes = parseInt($("#_06").val())
                                        var rowPerMM = parseInt($("#_07").val())
                                        var zeta = parseFloat($("#_08").val())
                                        var zMax = parseFloat($("#_09").val())
                                        var air = parseInt($("#_10").val())
                                        var flName = 'GC'

                                        function isValidInteger(value) {
                                                return Number.isInteger(value) && value >= 0
                                        }
                                        function isValidDecimal(value) {
                                                return typeof value === "number" && value >= 0
                                        }
                                        function isValidAir(value) {
                                                return value === 0 || value === 1
                                        }
                                        function isValidFlName(value) {
                                                return (typeof value === "string" &&
                                                        value.trim() !== "" &&
                                                        /^[a-zA-Z0-9_-]+$/.test(value))
                                        }
                                        function isUniqueFlName(value) {
                                                return !usedFileNames.includes(value)
                                        }

                                        if (!isValidInteger(minPWR)) throw new Error("minPWR must be a positive integer")
                                        if (!isValidInteger(maxPWR)) throw new Error("maxPWR must be a positive integer")
                                        if (!isValidInteger(speedTRVL)) throw new Error("speedTRVL must be a positive integer")
                                        if (!isValidInteger(speedLSR)) throw new Error("speedLSR must be a positive integer")
                                        if (!isValidInteger(passes)) throw new Error("passes must be a positive integer")
                                        if (!isValidInteger(rowPerMM)) throw new Error("rowPerMM must be a positive integer")
                                        if (!isValidAir(air)) throw new Error("air must be 0 or 1")
                                        if (!isValidFlName(flName)) throw new Error("flName must be a non-empty string")

                                        if (!isUniqueFlName(flName)) {
                                                flName = makeUniqueFlName(flName)
                                        }
                                        usedFileNames.push(flName)

                                        var gcode = '', pre = '', post = ''

                                        var now = new Date()
                                        now = ('0' + now.getDate()).slice(-2) + '/' +
                                              ('0' + (now.getMonth() + 1)).slice(-2) + '/' +
                                              now.getFullYear() + ' ' +
                                              ('0' + now.getHours()).slice(-2) + ':' +
                                              ('0' + now.getMinutes()).slice(-2) + ':' +
                                              ('0' + now.getSeconds()).slice(-2)

                                        function addAcc() {
                                                accX = document.getElementById('_11').value
                                                accY = document.getElementById('_11').value
                                                accZ = document.getElementById('_11').value
                                                return{accX, accY, accZ}
                                        }; addAcc()
                                        
                                        pre += "; Created using HobbyLaser " + now + "\n\n"
                                        pre += "; ======= PREAMBLE =======\n"
                                        pre += "; General machine settings\n"
                                        pre += "; mode:" + type + "\n"
                                        pre += "; Laser Speed: " + speedTRVL + " mm/min\n"
                                        pre += "; Travel Speed: " + speedLSR + " mm/min\n"
                                        pre += "; Power: [" + minPWR + ", " + maxPWR + "]\n\n"
                                        pre += "G21; units in mm\n"
                                        pre += "G90; absolute positioning\n"

                                        pre += "; Acceleration control\n"
                                        pre += "$120=" + accX + "; Acceleration X mm/s² (GRBL)\n"
                                        pre += "$121=" + accY + "; Acceleration Y mm/s² (GRBL)\n"
                                        pre += "$122=" + accZ + "; Acceleration Z mm/s² (GRBL)\n\n"
                                        
                                        pre += "G0 X0 Y0 Z0 F" + speedTRVL + "\n"
                                        if (air !== 0) pre += "M8; start airAssist\n"

                                        post += "\n; ======= POSTAMBLE =======\n"
                                        post += "G0 X0 Y0 Z0 F" + speedTRVL + "\n"
                                        if (air !== 0) post += "M9; stop airAssist\n"
                                        post += "M2; end program\n"
                                        post += "\n; ======= END JOB =======\n"

                                        return {minPWR, maxPWR, speedTRVL, speedLSR, passes, rowPerMM, zeta, zMax, air, flName, gcode, pre, post}
                                }

                                function svg2gc(md) {
                                        var type = 'vector'
                                        var settings = prepareGCodeSettings(type)
                                        var { minPWR, maxPWR, speedTRVL, speedLSR, passes, rowPerMM, zeta, zMax, flName, gcode, pre, post } = settings

                                        var Points = svgpath.replace(/,/g, ' ')
                                        var Points_1 = svgPathToPoints(Points)
                                        var pointsArray = Points_1.map(cmd => cmd.command + (cmd.values ? cmd.values.join(' ') : '')).join(' ')
                                        var Points_2 = svgPathToClipperPaths(pointsArray)
                                        var paths = use(Points_2.slice())
                                        var bounds = calculateBoundingBox(paths)                                  

                                        function contour() {
                                                var commentCol = 35, lineNum = 1

                                                function addLine(code, comment = "") {
                                                        const spaces = Math.max(commentCol - code.length, 1)
                                                        const padded = code + " ".repeat(spaces) + `; ${comment} [${lineNum}]`
                                                        gcode += padded + "\n"; lineNum++
                                                }

                                                for (let pass = 0; pass < passes; pass++) {
                                                        const zStep = zeta * pass
                                                        paths.forEach(originalPath => {
                                                                const path = originalPath.slice()
                                                                if (!path || path.length < 1) return

                                                                if (tabBool && path.length > 1) {
                                                                        const first = path[0]
                                                                        const last = path[path.length - 1]
                                                                        if (Math.abs(first.X - last.X) < 1e-6 && Math.abs(first.Y - last.Y) < 1e-6) path.pop()
                                                                }

                                                                const x0 = path[0].X.toFixed(2)
                                                                const y0 = (dHeight + 6 - path[0].Y).toFixed(2)

                                                                addLine(`G0 X${x0} Y${y0} Z${zMax} F${speedTRVL} S${minPWR}`, "Move to start")
                                                                addLine(`G1 X${x0} Y${y0} Z${zMax} F${Math.floor(speedTRVL/10)} S${minPWR}`, "stabilize laser")
                                                                addLine(`M3 S${minPWR}`, "Laser ON at initial power")

                                                                if (!tabBool) {
                                                                        addLine(`G1 X${x0} Y${y0} Z${zMax} F${speedTRVL} S0`, "Position for descent")
                                                                        addLine(`G1 X${x0} Y${y0} Z${zStep} F${speedLSR} S${maxPWR}`, "start job")
                                                                }

                                                                for (let i = 1; i < path.length; i++) {
                                                                        const x = path[i].X.toFixed(2)
                                                                        const y = (dHeight + 6 - path[i].Y).toFixed(2)
                                                                        addLine(`G1 X${x} Y${y} Z${zStep} F${speedLSR} S${maxPWR}`, `segment ${i}`)
                                                                }

                                                                addLine(`M5`, "Laser OFF")
                                                                addLine(`G0 Z${zMax} F${speedTRVL}`, "Retract to safe Z")
                                                        })
                                                }

                                                if (tabBool) {tabBool = false; updateButtons()}
                                        }

                                        function infillLines(rect) {
                                                var lines = []
                                                for (var y = rect[1]; y <= rect[3]; y += 1 / rowPerMM) {
                                                        var p1 = [rect[0], y]
                                                        var p2 = [rect[2], y]
                                                        lines.push([p1, p2])
                                                }
                                                return lines
                                        }

                                        function intersectInfill(infillLines) {
                                                window.alert = function () {}
                                                var clipper = new ClipperLib.Clipper()
                                                var infillPaths = infillLines.map(line => line.map(([x, y]) => ({ X: x * 1000, Y: y * 1000 })))
                                                var scaledPaths = JSON.parse(JSON.stringify(paths))
                                                ClipperLib.JS.ScaleUpPaths(scaledPaths, 1000)
                                                var result = new ClipperLib.Paths()
                                                clipper.AddPaths(infillPaths, ClipperLib.PolyType.ptSubject, false)
                                                clipper.AddPaths(scaledPaths, ClipperLib.PolyType.ptClip, true)
                                                clipper.Execute(ClipperLib.ClipType.ctIntersection, result, ClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero)
                                                ClipperLib.JS.ScaleDownPaths(result, 1000)
                                                return result
                                        }

                                        function engraveSegments(intersectedPaths) {
                                                if (!intersectedPaths || intersectedPaths.length === 0) return

                                                var commentCol = 35, lineNum = 1
                                                function addLine(code, comment = "") {
                                                        var spaces = Math.max(commentCol - code.length, 1)
                                                        var padded = code + " ".repeat(spaces) + `; ${comment} [${lineNum}]`
                                                        gcode += padded + "\n"; lineNum++
                                                }

                                                for (let pass = 0; pass < passes; pass++) {
                                                        var zStep = zeta * pass
                                                        var isForward = true

                                                        intersectedPaths.forEach(path => {
                                                                if (!path || path.length < 2) return

                                                                var ordered = isForward ? path.slice() : path.slice().reverse();
                                                                var p0 = ordered[0];
                                                                var x0 = p0.X !== undefined ? p0.X : p0[0]
                                                                var y0 = p0.Y !== undefined ? p0.Y : p0[1]

                                                                addLine(`M5`, "Laser OFF before move");
                                                                addLine(`G0 X${x0.toFixed(2)} Y${(dHeight + 6 - y0).toFixed(2)} Z${zMax} F${speedTRVL} S${minPWR}`, "Move to start");
                                                                addLine(`G1 X${x0.toFixed(2)} Y${(dHeight + 6 - y0).toFixed(2)} Z${zMax} F${Math.floor(speedTRVL / 10)} S${minPWR}`, "Stabilize laser (slow move)");
                                                                addLine(`M3 S${minPWR}`, "Laser ON at initial power")

                                                                ordered.forEach((p, i) => {
                                                                        const x = p.X !== undefined ? p.X : p[0]
                                                                        const y = p.Y !== undefined ? p.Y : p[1]
                                                                        addLine(`G1 X${x.toFixed(2)} Y${(dHeight + 6 - y).toFixed(2)} Z${zStep} F${speedLSR} S${maxPWR}`, `infill segment ${i + 1}`)
                                                                })

                                                                addLine(`M5`, "Laser OFF")
                                                                addLine(`G0 Z${zMax} F${speedTRVL}`, "Retract to safe Z")

                                                                isForward = !isForward
                                                        })
                                                }
                                        }                                       

                                        try {
                                                if (md == 0) {
                                                        contour(); addBoundingBox(gcode) 
                                                        gcode = pre + bbGCode + gcode + post
                                                } else {
                                                        var fill = infillLines([bounds.minX, bounds.minY, bounds.maxX, bounds.maxY])
                                                        var intersectedPaths = intersectInfill(fill)
                                                        engraveSegments(intersectedPaths)
                                                        contour(); addBoundingBox(gcode) 
                                                        gcode = pre + bbGCode + gcode + post
                                                }
                                                
                                                saveGCODE(gcode, flName, "vector"); GCSenderShow()
                                        } catch (e) {console.error(e.message)}
                                }

                                function img2gc() {
                                        try {
                                                var type = 'raster'
                                                var settings = prepareGCodeSettings(type)
                                                var {minPWR, maxPWR, speedTRVL, speedLSR, passes, rowPerMM, zeta, zMax, air, flName, gcode, pre, post, type} = settings

                                                var imageData = ctxIMG.getImageData(0, 0, scaledWidth, scaledHeight)
                                                var width = imageData.width, height = imageData.height, data = imageData.data

                                                function findActivePixelRange(y) {
                                                        var firstActivePixel = -1
                                                        var lastActivePixel = -1
                                                        for (var ix = 0; ix < width; ix++) {
                                                                var index = (y * width + ix) * 4
                                                                var red = data[index]
                                                                var green = data[index + 1]
                                                                var blue = data[index + 2]
                                                                var alpha = data[index + 3]
                                                                var isWhite = red > 240 && green > 240 && blue > 240
                                                                var isTransparent = alpha <= 10
                                                                if (!isWhite && !isTransparent) {
                                                                        if (firstActivePixel === -1) firstActivePixel = ix
                                                                        lastActivePixel = ix
                                                                }
                                                        }
                                                        return { firstActivePixel, lastActivePixel }
                                                }

                                                var commentCol = 35, lineNum = 1
                                                function addLine(code, comment = "") {
                                                        var spaces = Math.max(commentCol - code.length, 1)
                                                        var padded = code + " ".repeat(spaces) + `; ${comment} [${lineNum}]`
                                                        gcode += padded + "\n"; lineNum++
                                                }                                                
                                                function generatePassGcode(zOffset) {
                                                        const powerStep = 5;
                                                        const powerTolerance = 5;
                                                        const lineSpacing = 1 / rowPerMM;

                                                        for (let yMM = 0; yMM < convertToMM(height); yMM += lineSpacing) {
                                                                const y = Math.round(yMM * 96 / 25.4);
                                                                if (y >= height) break;

                                                                const { firstActivePixel, lastActivePixel } = findActivePixelRange(y);
                                                                if (firstActivePixel === -1) continue;

                                                                let startX = firstActivePixel;
                                                                let endX = lastActivePixel;
                                                                let step = (y % 2 === 0) ? 1 : -1;
                                                                if (step === -1) [startX, endX] = [endX, startX];

                                                                const yCoord = (dHeight - yMM) - borderY;
                                                                let drawing = false;
                                                                let lastPower = 0;

                                                                for (let ix = startX; ix !== endX + step; ix += step) {
                                                                        const idx = (y * width + ix) * 4;
                                                                        const red = data[idx];
                                                                        const green = data[idx + 1];
                                                                        const blue = data[idx + 2];
                                                                        const alpha = data[idx + 3];

                                                                        const isWhite = red > 240 && green > 240 && blue > 240;
                                                                        const isTransparent = alpha <= 10;

                                                                        let power = 0;
                                                                        if (!isWhite && !isTransparent) {
                                                                                const brightness = red * 0.3 + green * 0.59 + blue * 0.11;
                                                                                power = minPWR + (1.0 - brightness / 255.0) * (maxPWR - minPWR);
                                                                                power = Math.round(power / powerStep) * powerStep;
                                                                        }

                                                                        if (power > 0) {
                                                                                if (!drawing) {
                                                                                        const xCoord = convertToMM(ix) + borderX;
                                                                                        addLine(`G0 X${xCoord.toFixed(2)} Y${yCoord.toFixed(2)} Z${zMax} F${speedTRVL} S${minPWR}`, `Move to start raster`);
                                                                                        addLine(`G1 X${xCoord.toFixed(2)} Y${yCoord.toFixed(2)} Z${zOffset.toFixed(2)} F${speedLSR} S${power}`, `Laser ON`);
                                                                                        drawing = true;
                                                                                        lastPower = power;
                                                                                } else if (Math.abs(power - lastPower) > powerTolerance) {
                                                                                        const xCoord = convertToMM(ix) + borderX;
                                                                                        addLine(`G1 X${xCoord.toFixed(2)} Y${yCoord.toFixed(2)} Z${zOffset.toFixed(2)} F${speedLSR} S${lastPower}`, `Set power ${lastPower}`);
                                                                                        addLine(`G1 X${xCoord.toFixed(2)} Y${yCoord.toFixed(2)} Z${zOffset.toFixed(2)} F${speedLSR} S${power}`, `New power ${power} `);
                                                                                        lastPower = power;
                                                                                }
                                                                        } else if (drawing) {
                                                                                const xCoord = convertToMM(ix - step) + borderX;
                                                                                addLine(`G1 X${xCoord.toFixed(2)} Y${yCoord.toFixed(2)} Z${zOffset.toFixed(2)} F${speedLSR} S${lastPower}`, `Laser OFF`);
                                                                                drawing = false;
                                                                        }
                                                                }
                                                                if (drawing) {
                                                                        const xCoord = convertToMM(endX) + borderX;
                                                                        addLine(`G1 X${xCoord.toFixed(2)} Y${yCoord.toFixed(2)} Z${zOffset.toFixed(2)} F${speedLSR} S${lastPower}`, `Laser OFF`);
                                                                        drawing = false;
                                                                }
                                                        }
                                                }

                                                for (var pass = 0; pass < passes; pass++) {
                                                        generatePassGcode(pass * zeta)
                                                }

                                                addBoundingBox(gcode) 
                                                gcode = pre + bbGCode + gcode + post

                                                saveGCODE(gcode, flName, "raster"); GCSenderShow()
                                        } catch (error) {
                                                console.error(error.message)
                                        }
                                }
                                function roundCoord(coord){return Math.round(coord * 10) / 10}
                                function convertToMM(value, dpi = 96){var mmPerInch = 25.4; return (value / dpi) * mmPerInch}

                                function getCurrentGRBLValues() {
                                        var acc = Number(document.getElementById('_11').value) || 500

                                        var speedTRVL = Number(document.getElementById('_04').value) || 1000
                                        var speedLSR  = Number(document.getElementById('_05').value) || 600

                                        return {acc, speedTRVL, speedLSR}
                                }
                                function estimateJobTime(gcodeText, speedTRVL, speedLSR, accel, overheadPerCmd = 0.003, corrFactor = 1.15) {
                                        var lines = gcodeText.split(/\r?\n/)
                                        var timeSec = 0
                                        var last = {x: 0, y: 0, z: 0}
                                        var mmPerMinToMmPerSec = 1 / 60

                                        for (var raw of lines) {
                                                var line = raw.split(';')[0].trim()
                                                if (!line) continue
                                                timeSec += overheadPerCmd

                                                if (line.startsWith('G4')) {
                                                        var match = line.match(/P([\d.]+)/)
                                                        if (match) timeSec += parseFloat(match[1]) / 1000; continue
                                                }
                                                if (line.startsWith('M3') || line.startsWith('M4') || line.startsWith('M5')) {
                                                        timeSec += 0.01; continue
                                                }

                                                if (line.startsWith('G0') || line.startsWith('G1')) {
                                                        var args = {}
                                                        line.replace(/([XYZF])([\-\d.]+)/g, (_, k, v) => { args[k] = parseFloat(v) })

                                                        var x = args.X ?? last.x
                                                        var y = args.Y ?? last.y
                                                        var z = args.Z ?? last.z

                                                        var dist = Math.sqrt(
                                                                Math.pow((x - last.x), 2) +
                                                                Math.pow((y - last.y), 2) +
                                                                Math.pow((z - last.z), 2)
                                                        )

                                                        var feed = line.startsWith('G0') ? speedTRVL : speedLSR
                                                        if (args.F) feed = args.F
                                                        var speed = feed * mmPerMinToMmPerSec

                                                        var accelDist = (speed * speed) / (2 * accel)
                                                        var moveTime
                                                        if (dist < 2 * accelDist) {
                                                                moveTime = 2 * Math.sqrt(dist / accel)
                                                        } else {
                                                                var accelTime = speed / accel
                                                                var cruiseDist = dist - 2 * accelDist
                                                                var cruiseTime = cruiseDist / speed
                                                                moveTime = 2 * accelTime + cruiseTime
                                                        }

                                                        if (dist < 1) moveTime *= 2

                                                        var dynOverhead = overheadPerCmd * (1 + (1 / Math.max(dist, 0.05)))
                                                        timeSec += dynOverhead

                                                        if (/S\d+/.test(line)) {
                                                                moveTime *= 1.2
                                                        }

                                                        timeSec += moveTime
                                                        last = {x, y, z}
                                                }
                                        }
                                        return timeSec * corrFactor
                                }

                                var db, request = indexedDB.open("GCODE_DB", 1)
                                indexedDB.deleteDatabase("GCODE_DB")

                                request.onupgradeneeded = function(event) {
                                        db = event.target.result
                                        var fileStore = db.createObjectStore("gcode_files", { keyPath: "id", autoIncrement: true })
                                        fileStore.createIndex("name", "name", {unique: false})
                                        fileStore.createIndex("order", "order", {unique: false})
                                }

                                request.onsuccess = function(event) {
                                        db = event.target.result; loadFiles()
                                }

                                function saveGCODE(data, flName, mode) {
                                        var fileName = flName
                                        var gcode = data
                                        gc = data
                                        if (!fileName || !gcode) return

                                        var blob = new Blob([gcode], {type: "text/plain"})

                                        var transaction = db.transaction("gcode_files", "readwrite")
                                        var store = transaction.objectStore("gcode_files")

                                        store.getAll().onsuccess = function(e) {
                                                var files = e.target.result
                                                var nextOrder = files.length
                                                store.add({name:fileName, data:blob, mode:mode, order:nextOrder})
                                        }

                                        transaction.oncomplete = function() {
                                                gcode = ""; loadFiles()
                                        }
                                }

                                var gcodeText = ""
                                function loadFiles() {
                                        var speedTRVL = parseInt($("#_04").val())
                                        var speedLSR = parseInt($("#_05").val())
                                        var transaction = db.transaction("gcode_files", "readonly")
                                        var store = transaction.objectStore("gcode_files")
                                        var index = store.index("order")
                                        var request = index.getAll()

                                        request.onsuccess = function() {
                                                var fileList = document.getElementById("fileList")
                                                fileList.innerHTML = ""

                                                request.result.forEach(file => {
                                                        var li = document.createElement("li")
                                                        li.textContent = "   ├── " + file.name + " [" + (file.mode || "vector") + "]"
                                                        li.dataset.id = file.id
                                                        li.setAttribute("draggable", "true")

                                                        li.addEventListener("dragstart", function(e) {
                                                                e.dataTransfer.setData("text/plain", li.dataset.id)
                                                                li.classList.add("dragging")
                                                                li.classList.add("ghost")
                                                                draggedElement = li
                                                        })

                                                        li.addEventListener("dragend", function() {
                                                                li.classList.remove("dragging")
                                                                li.classList.remove("ghost")
                                                                saveOrder()
                                                        })

                                                        li.addEventListener("dragover", function(e) {
                                                                e.preventDefault()
                                                                var dragging = document.querySelector(".dragging")
                                                                if (dragging && dragging !== li) {
                                                                        var parent = li.parentNode
                                                                        var rect = li.getBoundingClientRect()
                                                                        var offset = e.clientY - rect.top
                                                                        if (offset > rect.height / 2) {
                                                                                parent.insertBefore(dragging, li.nextSibling)
                                                                        } else {
                                                                                parent.insertBefore(dragging, li)
                                                                        }
                                                                }
                                                        })

                                                        var buttonContainer = document.createElement("div")
                                                        buttonContainer.classList.add("button-container")

                                                        var downloadBtn = document.createElement("button")
                                                        downloadBtn.textContent = "download"
                                                        downloadBtn.classList.add("btTool")
                                                        downloadBtn.onclick = function() { downloadFile(file) }

                                                        var deleteBtn = document.createElement("button")
                                                        deleteBtn.textContent = "delete"
                                                        deleteBtn.classList.add("btTool")
                                                        deleteBtn.onclick = function() { deleteFile(file.id) }

                                                        var dBtn = document.createElement("button")
                                                        dBtn.textContent = "add view"
                                                        dBtn.classList.add("btTool")
                                                        dBtn.onclick = function() { 
                                                                var reader = new FileReader()
                                                                reader.onload = function(e) {
                                                                        gcodeText = e.target.result
                                                                        isImageMode = (file.mode === "raster")
                                                                        clrScene(scene); gcVIEW(gcodeText)
                                                                        var {acc, speedTRVL, speedLSR} = getCurrentGRBLValues()
                                                                        var estSec = estimateJobTime(gcodeText, speedTRVL, speedLSR, acc)

                                                                        var h = Math.floor(estSec / 3600)
                                                                        var m = Math.floor((estSec % 3600) / 60)
                                                                        var s = Math.floor(estSec % 60)
                                                                        document.getElementById('time').textContent = `estimtedTime: ${h}h ${m}m ${s}s`
                                                                }; reader.readAsText(file.data)
                                                        }

                                                        buttonContainer.appendChild(dBtn)
                                                        buttonContainer.appendChild(downloadBtn)
                                                        buttonContainer.appendChild(deleteBtn)

                                                        li.appendChild(buttonContainer)
                                                        fileList.appendChild(li)
                                                })
                                        }
                                }

                                function saveOrder() {
                                        var items = document.querySelectorAll("#fileList li")
                                        var transaction = db.transaction("gcode_files", "readwrite")
                                        var store = transaction.objectStore("gcode_files")

                                        items.forEach((li, index) => {
                                                var id = parseInt(li.dataset.id)
                                                var request = store.get(id)
                                                request.onsuccess = function() {
                                                        var file = request.result
                                                        if (!file) return
                                                        file.order = index
                                                        store.put(file)
                                                }
                                        })
                                }

                                function downloadFile(file) {
                                        if (!gc || typeof gc !== "string" || gc.trim() === "") return

                                        const blob = new Blob([gc], { type: "text/plain" })
                                        const url = URL.createObjectURL(blob)
                                        
                                        //var url = URL.createObjectURL(file.data)
                                        var a = document.createElement("a")
                                        a.href = url
                                        a.download = file.name + ".nc"
                                        document.body.appendChild(a)
                                        a.click()
                                        document.body.removeChild(a)
                                }

                                function deleteFile(id) {
                                        var transaction = db.transaction("gcode_files", "readwrite")
                                        var store = transaction.objectStore("gcode_files")
                                        store.delete(id)
                                        transaction.oncomplete = function() {
                                                loadFiles()
                                        }
                                }

                                var addQUEUE = function() {
                                        var transaction = db.transaction("gcode_files", "readonly")
                                        var store = transaction.objectStore("gcode_files")
                                        var index = store.index("order")
                                        var request = index.getAll() 

                                        request.onsuccess = function() {
                                                var files = request.result
                                                if (files.length < 2) return

                                                var combinedText = ""
                                                var filesRead = 0

                                                files.forEach((file, index) => {
                                                        var reader = new FileReader()
                                                        reader.onload = function(e) {
                                                                var content = e.target.result

                                                                combinedText += `\n; ===== START FILE ${file.name} =====\n`
                                                                combinedText += `\n; type:combined\n`
                                                                combinedText += content;
                                                                combinedText += `\n; ===== END FILE ${file.name} =====\n`

                                                                filesRead++
                                                                if (filesRead === files.length) {
                                                                        saveGCODE(combinedText, "COMB.", "combined")
                                                                }
                                                        }; 
                                                        reader.readAsText(file.data);
                                                })
                                        }
                                }
                        </script>
                </div>
                
                <div id="GCSender" style="">                
                        <div id="leftPanel" style="background:#101010; position:absolute; width:200px; top:100px; z-index:500;
                        left:calc(50% - (var(--viewWidth) / 2) - 100px); border:1px solid #3c3c3c; z-index:500; visibility:hidden">

                                <button id="connect" class="btAlert" style="position:absolute; left:10px; top:10px">connect</button>
                                <button id="stop" class="btAlert" style="position:absolute; left:10px; top:45px">Stop</button>                
                                <button id="send" class="btAlert" style="position:absolute; left:10px; top:80px">Send ...</button>
                                <button id="pause" class="btAlert" style="position:absolute; left:10px; top:115px">Pause</button>
                                <button id="resume" class="btAlert" style="position:absolute; left:10px; top:150px">Resume</button>

                                <button id="config"class="btAlert" style="position:absolute;  margin-left:10px; bottom:10px">setGRBL</button>

                                <input class="txtInp" type="text" id="cmd" style="text-align:center;
                                position:absolute; left:10px; top:200px; width:177px" placeholder="send command 'ctrl + enter'"/>

                                <div id="grbl" style="position:absolute; bottom:100px; left:10px; right:5px;
                                color:gray; font-size:12px; line-height:1.4; white-space:pre-wrap;"></div>                                    
       
                        </div>             

                        <div id="centerPanel" class="panel" style="position:absolute; top:100px; left:0; overflow:hidden; visibility:hidden">
                                <span id="spinner" style="position:absolute; top:50%; left:50%; width:20px; transform:translate(-50%,-50%)"></span>
                                <div id="3dView">
                                        <script>                                        
                                                //------ gcode VIEW
                                                function clrScene(scene) {
                                                        while (scene.children.length > 0) {
                                                                var obj = scene.children[0];
                                                                if (obj.geometry) obj.geometry.dispose();
                                                                if (obj.material) obj.material.dispose();
                                                                scene.remove(obj);
                                                        }
                                                }

                                                function GCodeParser(handlers) {
                                                        this.handlers = handlers || {}
                                                }
                                                GCodeParser.prototype.parseLine = function (text) {
                                                        var comment = null
                                                        var semicolonIndex = text.indexOf(';')
                                                        if (semicolonIndex >= 0) {
                                                                comment = text.substring(semicolonIndex).trim()
                                                                text = text.substring(0, semicolonIndex).trim() 
                                                        }

                                                        if (comment && this.handlers['comment']) {
                                                                this.handlers['comment'](comment)
                                                        }

                                                        if (text) {
                                                                var tokens = text.split(' ')
                                                                var cmd = tokens[0]
                                                                var args = { cmd: cmd }
                                                                tokens.slice(1).forEach(function (token) {
                                                                        if (token.length < 2) return
                                                                        var key = token[0].toLowerCase()
                                                                        var value = parseFloat(token.substring(1))
                                                                        if (!isNaN(value)) {
                                                                                args[key] = value
                                                                        }
                                                                })
                                                                var handler = this.handlers[cmd] || this.handlers['default']
                                                                if (handler) {
                                                                        handler(args)
                                                                }
                                                        }
                                                }
                                                GCodeParser.prototype.parse = function (gcode) {
                                                        var lines = gcode.split('\n')
                                                        for (var i = 0; i < lines.length; i++) {
                                                                this.parseLine(lines[i])
                                                        }
                                                }

                                                function createObjFromGC(gcode) {
                                                        var positions = [], colors = [], pathPoints = [], lastLine = { x: 0, y: 0, z: 0 }
                                                        var visitedSegments = [], lastPower = 0
                                                        var inBB = false 
                                                        var bbColor = new THREE.Color(0x555555) 
                                                        var isImageMode = gcode.includes('; mode:raster')

                                                        function addSegment(p1, p2, power, isBB) {
                                                                positions.push(p1.x, p1.y, p1.z)
                                                                positions.push(p2.x, p2.y, p2.z)

                                                                var color
                                                                if (isBB) {
                                                                        color = bbColor
                                                                } else {
                                                                        var intensity = power / 255
                                                                        if (isImageMode) intensity = 1 - intensity
                                                                        color = new THREE.Color().setRGB(intensity, intensity, intensity)
                                                                }

                                                                colors.push(color.r, color.g, color.b)
                                                                colors.push(color.r, color.g, color.b)

                                                                pathPoints.push({ ...p2 })
                                                                visitedSegments.push(false)
                                                        }

                                                        function moveTo(args) {
                                                                if ('s' in args) lastPower = args.s

                                                                var zOffset = isImageMode ? -lastPower / 255 : 0
                                                                var zReal = args.z ?? lastLine.z

                                                                var newLine = {
                                                                        x: args.x ?? lastLine.x,
                                                                        y: args.y ?? lastLine.y,
                                                                        z: zReal + zOffset
                                                                }

                                                                addSegment(lastLine, newLine, lastPower, inBB)
                                                                lastLine = { ...newLine }
                                                        }

                                                        function moveWithoutDrawing(args) {
                                                                if ('s' in args) lastPower = args.s
                                                                var zReal = args.z ?? lastLine.z
                                                                lastLine = {
                                                                        x: args.x ?? lastLine.x,
                                                                        y: args.y ?? lastLine.y,
                                                                        z: zReal
                                                                }
                                                        }

                                                        var parser = new GCodeParser({
                                                                comment: c => {
                                                                        if (c.includes('start BB')) inBB = true
                                                                        if (c.includes('end BB')) inBB = false
                                                                },
                                                                G0: args => moveWithoutDrawing(args),
                                                                G1: args => moveTo(args)
                                                        })

                                                        parser.parse(gcode)

                                                        if (positions.length === 0) return null

                                                        var geometry = new THREE.BufferGeometry()
                                                        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3))
                                                        geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3))
                                                        geometry.computeBoundingBox()

                                                        var center = geometry.boundingBox.getCenter(new THREE.Vector3())
                                                        var size = geometry.boundingBox.getSize(new THREE.Vector3()).length()

                                                        var posAttr = geometry.getAttribute('position')
                                                        for (var i = 0; i < posAttr.count; i++) {
                                                                posAttr.setXYZ(
                                                                        i,
                                                                        posAttr.getX(i) - center.x,
                                                                        posAttr.getY(i) - center.y,
                                                                        posAttr.getZ(i) - center.z
                                                                )
                                                        }
                                                        posAttr.needsUpdate = true

                                                        pathPoints = pathPoints.map(p => ({
                                                                x: p.x - center.x,
                                                                y: p.y - center.y,
                                                                z: p.z - center.z
                                                        }))

                                                        var material = new THREE.LineBasicMaterial({ vertexColors: true })
                                                        var line = new THREE.LineSegments(geometry, material)

                                                        return { line, pathPoints, center, size }
                                                }

                                                var view = document.getElementById("3dView")
                                                var tW = window.innerHeight * 0.6
                                                var tH = window.innerHeight * 0.6

                                                var renderer = new THREE.WebGLRenderer({antialias: true})
                                                renderer.setSize(tW, tH)
                                                renderer.setPixelRatio(window.devicePixelRatio)
                                                renderer.setClearColor(0x101010, 1)
                                                view.appendChild(renderer.domElement)

                                                var scene = new THREE.Scene()
                                                var camera = new THREE.PerspectiveCamera(40, tW / tH, 1, 1000)
                                                camera.lookAt(0,0,0); camera.up.set(0, 1, 0)
                                                var controls = new THREE.OrbitControls(camera, renderer.domElement)
                                                controls.enableKeys = false
                                                
                                                function resetCAMERA() {
                                                        camera = new THREE.PerspectiveCamera(40, tW / tH, 0.1, 1000)
                                                        camera.position.set(5, -22, 138)
                                                        controls = new THREE.OrbitControls(camera, renderer.domElement)
                                                        controls.enableKeys = false; controls.update()
                                                }

                                                function loop() {
                                                        requestAnimationFrame(loop)
                                                        controls.update()
                                                        renderer.render(scene, camera)
                                                }; loop()

                                                function renderGCode(object) {
                                                        clrScene(scene); scene.add(object)
                                                        if (typeof line !== 'undefined' && line !== null) {
                                                                scene.add(line)
                                                        }
                                                        camera.position.set(5, -22, 138)
                                                        camera.lookAt(center)
                                                }

                                                var pathPoints = [], isPaused = false, step = 0, object
                                                var gcVIEW = function (gcode) {
                                                        var result = createObjFromGC(gcode); if (!result) return
                                                        object = result.line; pathPoints = result.pathPoints
                                                        center = result.center; size = result.size

                                                        renderGCode(object)
                                                        view.style.visibility = 'visible'
                                                }

                                                window.addEventListener('resize', function () {
                                                        tW = view.offsetWidth
                                                        tH = view.offsetHeight
                                                        renderer.setSize(tW, tH)
                                                        camera.aspect = tW / tH
                                                        camera.updateProjectionMatrix()
                                                })

                                                var frames = ['⠋','⠙','⠹','⠸','⠼','⠴','⠦','⠧','⠇','⠏'];
                                                var interval = 80, timer
                                                function startSpinner() {
                                                        var i = 0;
                                                        var el = document.getElementById("spinner");
                                                        timer = setInterval(() => {
                                                                el.textContent = frames[i % frames.length]; i++
                                                        }, interval); return timer
                                                }

                                                function stopSpinner() {
                                                        clearInterval(timer)
                                                        document.getElementById("spinner").textContent = ""
                                                }
                                        </script>
                                </div>    
                        </div>

                        <div id="configArea" class="panel" style="position:absolute; top:100px; left:0; overflow:auto; display:none">                
                                <table id="configTable">
                                        <thead>
                                                <tr>
                                                        <th style="text-align:left"></th>
                                                        <th style="text-align:right"></th>
                                                        <th style="text-align:right"></th>
                                                </tr>
                                        </thead>
                                        <tbody>
                                                <!-- Le righe saranno aggiunte dinamicamente qui -->
                                        </tbody>
                                </table>

                                <script>
                                        var accX = '', accY = '', accZ = ''
                                
                                        var configVisible = false
                                        document.getElementById('config').addEventListener('click', function () {
                                                if (isConnected == true) {
                                                        configVisible = !configVisible
                                                        if (configVisible) {
                                                                loadConfigData()
                                                                $("#configArea").show()
                                                                $("#pre, #post, label[for='pre'], label[for='post']").show()
                                                        } else {
                                                                $("#configArea").hide()
                                                                $("#pre, #post, label[for='pre'], label[for='post']").hide()
                                                                sendConfigToGRBL()
                                                        }
                                                } else {
                                                        console.error("ConnectController");
                                                }
                                        });

                                        function loadConfigData() {
                                                accX = document.getElementById('_11').value
                                                accY = document.getElementById('_11').value
                                                accZ = document.getElementById('_11').value
                                                
                                                $('#configTable tbody').empty()

                                                var configData = [
                                                        { setting: "$0", value: "10", description: "Step pulse time, microseconds" },
                                                        { setting: "$1", value: "25", description: "Step idle delay, milliseconds" },
                                                        { setting: "$2", value: "0", description: "Step pulse invert, mask" },
                                                        { setting: "$3", value: "0", description: "Step direction invert, mask" },
                                                        { setting: "$4", value: "0", description: "Invert step enable pin, boolean" },
                                                        { setting: "$5", value: "0", description: "Invert limit pins, boolean" },
                                                        { setting: "$6", value: "0", description: "Invert probe pin, boolean" },
                                                        { setting: "$10", value: "255", description: "Status report options, mask" },
                                                        { setting: "$11", value: "0.010", description: "Junction deviation, millimeters" },
                                                        { setting: "$12", value: "0.002", description: "Arc tolerance, millimeters" },
                                                        { setting: "$13", value: "0", description: "Report in inches, boolean" },
                                                        { setting: "$20", value: "0", description: "Soft limits enable, boolean" },
                                                        { setting: "$21", value: "0", description: "Hard limits enable, boolean" },
                                                        { setting: "$22", value: "1", description: "Homing cycle enable, boolean" },
                                                        { setting: "$23", value: "0", description: "Homing direction invert, mask" },
                                                        { setting: "$24", value: "25.000", description: "Homing locate feed rate, mm/min" },
                                                        { setting: "$25", value: "500.000", description: "Homing search seek rate, mm/min" },
                                                        { setting: "$26", value: "250", description: "Homing switch debounce delay, milliseconds" },
                                                        { setting: "$27", value: "1.000", description: "Homing switch pull-off distance, millimeters" },
                                                        { setting: "$30", value: "1000", description: "Maximum spindle speed, RPM" },
                                                        { setting: "$31", value: "0", description: "Minimum spindle speed, RPM" },
                                                        { setting: "$32", value: "1", description: "Laser-mode enable, boolean" },
                                                        { setting: "$100", value: "250.000", description: "X-axis steps per millimeter" },
                                                        { setting: "$101", value: "250.000", description: "Y-axis steps per millimeter" },
                                                        { setting: "$102", value: "250.000", description: "Z-axis steps per millimeter" },
                                                        { setting: "$110", value: "500.000", description: "X-axis maximum rate, mm/min" },
                                                        { setting: "$111", value: "500.000", description: "Y-axis maximum rate, mm/min" },
                                                        { setting: "$112", value: "500.000", description: "Z-axis maximum rate, mm/min" },
                                                        { setting: "$120", value: accX, description: "X-axis acceleration, mm/sec^2" },
                                                        { setting: "$121", value: accY, description: "Y-axis acceleration, mm/sec^2" },
                                                        { setting: "$122", value: accZ, description: "Z-axis acceleration, mm/sec^2" },
                                                        { setting: "$130", value: dWidth, description: "X-axis maximum travel, millimeters" },
                                                        { setting: "$131", value: dHeight, description: "Y-axis maximum travel, millimeters" },
                                                        { setting: "$132", value: "200.000", description: "Z-axis maximum travel, millimeters" }
                                                ];

                                                configData.forEach(data => {
                                                        var row = `<tr>
                                                                        <td>${'&nbsp;&nbsp;' + data.setting}</td>
                                                                        <td><input class="txtInp configValue" type="text" value="${data.value}"></td>
                                                                        <td style="padding-left:50px">${data.description}</td>
                                                                </tr>`;
                                                        $('#configTable tbody').append(row);
                                                });
                                        }

                                        function getConfigData() {
                                                var configData = []
                                                $('#configTable tbody tr').each(function () {
                                                        var key = $(this).find('td').eq(0).text().trim()
                                                        var value = $(this).find('input').val()
                                                        var description = $(this).find('td').eq(2).text()

                                                        if (key && value) {
                                                                configData.push({setting: key, value: value, description: description})
                                                        }
                                                }); return configData
                                        }

                                        var isSendingConfig = false
                                        async function sendConfigToGRBL() {
                                                if (isSendingConfig) return
                                                if (!writer) {
                                                        console.error("ConnectController"); return
                                                }

                                                isSendingConfig = true
                                                var config = getConfigData()
                                                for (var item of config) {
                                                        if (!item.setting || item.value === undefined) {
                                                                console.warn("invalid config item:", item); continue
                                                        }

                                                        var line = `${item.setting}=${item.value}`
                                                        try {
                                                                await new Promise(async (resolve, reject) => {
                                                                        var timeout = setTimeout(() => {
                                                                                reject("Timeout waiting for OK from GRBL")
                                                                        }, OK_TIMEOUT)
                                                                        enqueueOkResolver(() => {
                                                                                clearTimeout(timeout); resolve()
                                                                        })
                                                                        await writer.write(encoder.encode(line + "\n"))
                                                                })
                                                        } catch (err) {
                                                                console.error("Error sending config:", err)
                                                        }
                                                }; isSendingConfig = false
                                        }
                                </script>
                        </div>

                        <div id="rightPanel" style="background:#101010; position:absolute; width:500px; top:100px; z-index:500;
                        border:1px solid #3c3c3c; visibility:hidden">

                                <button id="close" class="close-btn" onclick="GCSenderHide()">x</button>

                                <div id="time" style="position:absolute; bottom:5px; left:10px; right:5px;
                                color:gray; font-size:12px; line-height:1.4; white-space:pre-wrap;">estimtedTime:</div>

                                <div style="position:absolute; top:60px; left:20px; font-size:12px">[CACHE STORAGE]</div>

                                <div id="crud-wrapper" style="">              
                                        <div id="crud"> <ul id="fileList"></ul></div>
                                </div>

                                <button id="print" class="btTool" style="position:absolute;
                                width:100px; bottom:8px; right:10px" onclick="addBoundingBox()">addBB</button>
                        </div>

                         <script>
                                var centerPanel = document.getElementById('centerPanel')
                                var centPHeight = centerPanel.offsetHeight

                                window.addEventListener('DOMContentLoaded', function () {
                                        var leftPanel = document.getElementById("leftPanel")
                                        var rightPanel = document.getElementById("rightPanel")
                                        var confArea = document.getElementById('configArea')

                                        leftPanel.style.height = centPHeight + "px"
                                        rightPanel.style.height = centPHeight + "px"

                                        var leftWidth = 200
                                        var centerWidth = centPHeight
                                        var rightWidth = 500  //230

                                        var totalWidth = leftWidth + centerWidth + rightWidth
                                        var startX = (window.innerWidth - totalWidth) / 2

                                        leftPanel.style.left = startX + "px"
                                        centerPanel.style.left = (startX + leftWidth +20) + "px"
                                        confArea.style.left = (startX + leftWidth +20) + "px"
                                        rightPanel.style.left = (startX + leftWidth + centerWidth+40) + "px"
                                })             

                                var sidePanel = document.getElementById("leftPanel")
                                sidePanel.style.height = tH + 5 + "px"

                                var centerX = window.innerWidth / 2
                                var viewLeft = centerX - (tW / 2)
                                sidePanel.style.left = (viewLeft - 120) + "px"
                                
                                  
                                // ------ GCSender
/* =========================
        VARIABILI GLOBALI
========================= */
var progressBar = document.getElementById('progress-bar')
var port, writer, reader, readableStreamClosed
var isSending = false, stopRequested = false, isPaused = false, reconnecting = false
var encoder = new TextEncoder(), reconnectDelay = 500
var isConnected = false, isManualDisconnect = false
var okQueue = [], statusListeners = []
var lineNumber = 0, lastStatusReq = 0
var totalGCodeLines = 0, sentGCodeLines = 0
var parser, lastLine, lastPower, center = {x: 0, y: 0, z: 0}
var pingInterval, OK_TIMEOUT = 1000
var lastLineSent, error2Count = 0

/* =========================
        UTILITIES
========================= */
function enqueueOkResolver(resolve) {
        okQueue.push(resolve)
}

function clearOkQueue() {
        while (okQueue.length) {
                try {okQueue.shift()(new Error('streaming aborted'))} catch(e){}
        }
}

function formatGcodeLine(rawLine){
        return rawLine.trim() + '\n'
}

/* =========================
        PARSER 3D
========================= */
function makeStreamParser(scene) {
        let segments = []
        let currentSegmentIndex = 0
        let currentSegmentProgress = 0
        let completedLineMeshes = []
        let activeLineMesh = null
        let laserMesh = null

        let inBB = false
        const bbColor = new THREE.Color(0x555555)
        const minSegmentDuration = 0.02
        const laserHeight = 4.0
        const defaultFeed = 1200

        function dist(a, b) {
                const dx = a.x - b.x
                const dy = a.y - b.y
                const dz = a.z - b.z
                return Math.sqrt(dx * dx + dy * dy + dz * dz)
        }

        const speedFactor = 0.2
        function calcDuration(length, feed) {
                const feedUsed = (feed && feed > 0) ? feed : defaultFeed
                const speed_mm_per_sec = feedUsed / 60
                const duration = speed_mm_per_sec > 0 ? (length / speed_mm_per_sec) : (length * 0.01)
                return Math.max(duration * speedFactor, minSegmentDuration)
        }

        let running = false
        function animateLoop(timestamp) {
                if (currentSegmentIndex >= segments.length) {
                        if (running) requestAnimationFrame(animateLoop)
                        return
                }

                const seg = segments[currentSegmentIndex]
                if (typeof seg._lastTimestamp === 'undefined') seg._lastTimestamp = timestamp || performance.now()
                const now = timestamp || performance.now()
                const dt = (now - seg._lastTimestamp) / 1000
                seg._lastTimestamp = now
                seg._elapsed = (seg._elapsed || 0) + dt
                currentSegmentProgress = Math.min(1, seg._elapsed / seg.duration)

                const x = seg.oldPt.x + (seg.newPt.x - seg.oldPt.x) * currentSegmentProgress
                const y = seg.oldPt.y + (seg.newPt.y - seg.oldPt.y) * currentSegmentProgress
                const z = seg.oldPt.z + (seg.newPt.z - seg.oldPt.z) * currentSegmentProgress

                // === linea attiva ===
                if (!activeLineMesh) {
                        const geom = new THREE.BufferGeometry().setFromPoints([
                                new THREE.Vector3(seg.oldPt.x, seg.oldPt.y, seg.oldPt.z),
                                new THREE.Vector3(x, y, z)
                        ])

                        const color = seg.inBB ? bbColor : new THREE.Color(seg.powerRatio, seg.powerRatio, seg.powerRatio)
                        geom.setAttribute('color', new THREE.Float32BufferAttribute([
                                color.r, color.g, color.b, color.r, color.g, color.b
                        ], 3))

                        const mat = new THREE.LineBasicMaterial({ vertexColors: true })
                        activeLineMesh = new THREE.Line(geom, mat)
                        scene.add(activeLineMesh)
                } else {
                        activeLineMesh.geometry.setFromPoints([
                                new THREE.Vector3(seg.oldPt.x, seg.oldPt.y, seg.oldPt.z),
                                new THREE.Vector3(x, y, z)
                        ])
                        activeLineMesh.geometry.attributes.position.needsUpdate = true
                }

                // === laser ===
                if (!laserMesh) {
                        const radius = 0.5
                        const laserGeom = new THREE.ConeGeometry(radius, laserHeight, 16)
                        const laserMat = new THREE.MeshBasicMaterial({ color: 0x0000ff })
                        laserMesh = new THREE.Mesh(laserGeom, laserMat)
                        scene.add(laserMesh)
                }

                const laserTop = new THREE.Vector3(x, y, z + laserHeight)
                const laserBottom = new THREE.Vector3(x, y, z)
                const dir = new THREE.Vector3().subVectors(laserBottom, laserTop)
                const length = dir.length()
                dir.normalize()
                laserMesh.scale.set(1, length / laserHeight, 1)
                const axis = new THREE.Vector3(0, 1, 0)
                const quaternion = new THREE.Quaternion().setFromUnitVectors(axis, dir)
                laserMesh.setRotationFromQuaternion(quaternion)
                const center = new THREE.Vector3().addVectors(laserTop, laserBottom).multiplyScalar(0.5)
                laserMesh.position.copy(center)

                if (currentSegmentProgress >= 1) {
                        activeLineMesh.geometry.setFromPoints([
                                new THREE.Vector3(seg.oldPt.x, seg.oldPt.y, seg.oldPt.z),
                                new THREE.Vector3(seg.newPt.x, seg.newPt.y, seg.newPt.z)
                        ])
                        completedLineMeshes.push(activeLineMesh)
                        activeLineMesh = null
                        currentSegmentIndex++
                        currentSegmentProgress = 0
                }

                if (running) requestAnimationFrame(animateLoop)
        }

        function ensureAnimationRunning() {
                if (!running) {
                        stopSpinner()
                        running = true
                        requestAnimationFrame(animateLoop)
                }
        }

        // === istanzia il parser ===
        const parser = new GCodeParser({
                G0: args => {
                        if ('s' in args) lastPower = args.s
                        const zReal = ('z' in args) ? args.z : lastLine.z
                        lastLine = { x: args.x ?? lastLine.x, y: args.y ?? lastLine.y, z: zReal }
                },

                G1: args => {
                        if ('s' in args) lastPower = args.s
                        const powerRatio = isImageMode ? 1 - (lastPower / 255) : (lastPower / 255)
                        const zReal = ('z' in args) ? args.z : lastLine.z
                        const zOffset = -powerRatio
                        const newPt = {
                                x: (args.x ?? lastLine.x) - center.x,
                                y: (args.y ?? lastLine.y) - center.y,
                                z: (zReal + zOffset) - center.z
                        }
                        const oldPt = {
                                x: lastLine.x - center.x,
                                y: lastLine.y - center.y,
                                z: lastLine.z + zOffset - center.z
                        }
                        const length = dist(oldPt, newPt)
                        const feed = ('f' in args) ? args.f : undefined
                        const duration = calcDuration(length, feed)
                        segments.push({
                                oldPt, newPt, powerRatio, feed,
                                length, duration, _elapsed: 0, inBB
                        })
                        lastLine = { x: args.x ?? lastLine.x, y: args.y ?? lastLine.y, z: zReal }
                        ensureAnimationRunning()
                }
        })

        return {
                parseLine: (line) => {
                        const trimmed = line.trim()
                        if (trimmed.startsWith(';')) {
                                const text = trimmed.toLowerCase().replace(/[^a-z0-9 ]/g, '').trim()
                                if (text.includes('start bb')) inBB = true
                                if (text.includes('end bb')) inBB = false
                                return
                        }
                        parser.parseLine(line)
                }
        }
}

/* =========================
        WEB WORKER
========================= */
var workerCode = `
        var lines = [], currentIndex = 0, paused = false, stopped = false

        self.onmessage = (e) => {
                var { cmd, data } = e.data
                if (cmd === 'start') {
                        lines = data.lines
                                .map(l => l.replace(/\\(.*?\\)/g, ''))   
                                //.map(l => l.split(';')[0].trim())       
                                .filter(l => l.length > 0)               
                        currentIndex = 0; paused = false
                        stopped = false; pump()
                }
                else if (cmd === 'ok') { pump() }
                else if (cmd === 'pause') { paused = true }
                else if (cmd === 'resume') { paused = false; pump() }
                else if (cmd === 'stop') { stopped = true }
        }

        async function pump() {
                if (stopped) {
                        self.postMessage({type: 'stopped'})
                        return
                }
                if (paused) return
                if (currentIndex >= lines.length) {
                        self.postMessage({type: 'done'})
                        return
                }

                var raw = lines[currentIndex++]

                // --- Riconosci ; PAUSE:xxx (millisecondi) o G4 Pxxx
                if (/^;\\s*PAUSE[:=]/i.test(raw)) {
                        var ms = parseInt(raw.split(/[:=]/)[1])
                        if (!isNaN(ms)) {
                                self.postMessage({type: 'pause', time: ms})
                                return
                        }
                }
                var dwell = raw.match(/^G0?4\\s+P([\\d\\.]+)/i)
                if (dwell) {
                        var sec = parseFloat(dwell[1])
                        if (!isNaN(sec)) {
                                self.postMessage({type: 'pause', time: sec * 1000})
                                return
                        }
                }
                self.postMessage({type: 'send', line: {raw, formatted: raw + '\\n'}})
        }
`
var blob = new Blob([workerCode], {type: 'application/javascript'})
var worker = new Worker(URL.createObjectURL(blob))
worker.onerror = e => console.error("Worker error:", e.message)

/* =========================
        STREAMING G-CODE
========================= */

async function streamGCodeWorkerMain(){
        if (!gcodeText || !gcodeText.trim()) return console.warn("G-code empty")
        if (isSending) return console.warn("Streaming in progress")
        if (!isConnected || !writer) {
                try {
                        await connectSerial()
                        await new Promise(r => setTimeout(r, 100))
                } catch(e) {
                        return console.error("Cannot connect:", e)
                }
        }
        stopPingGRBL()
        clrScene && clrScene(scene)
        var pre = createObjFromGC && createObjFromGC(gcodeText)
        if (pre) center = pre.center
        lastLine = {x:0, y:0, z:0}
        lastPower = 0
        parser = makeStreamParser(scene)
        var lines = gcodeText.split('\n')
        totalGCodeLines = lines.filter(l => l.trim() && !l.startsWith(';')).length
        sentGCodeLines = 0; lineNumber = 0
        isSending = true; stopRequested = false
        startSpinner(); worker.postMessage({cmd:'start', data:{lines}})
}

/* =========================
        WORKER HANDLER
========================= */
worker.onmessage = async (e) => {
        var msg = e.data

        if (msg.type === 'send') {
                var { raw, formatted } = msg.line;
                console.log("→ Sending:", formatted.trim())
                try {
                        lastLineSent = formatted;
                        try { parser.parseLine(raw) } catch (err) {console.warn("parse error:", err)}

                        sentGCodeLines++; updateProgressBar()
                        await writer.write(encoder.encode(formatted));
                        startPingGRBL()
                        await new Promise(resolve => enqueueOkResolver(resolve));
                } catch (e) { console.error("Error sending line:", e) }

                worker.postMessage({cmd: 'ok'})
        } else if (msg.type === 'pause') {
                var ms = msg.time || 0
                await new Promise(r => setTimeout(r, ms))
                worker.postMessage({cmd: 'ok'})
        } else if (msg.type === 'done') {
                isSending = false; stopPingGRBL()
                console.log("Streaming completed")
                //disconnectSerial(); GCSenderHide()
        } else if (msg.type === 'stopped') {
                isSending = false; clearOkQueue()
                console.log("Streaming stopped")
        }
}

/* =========================
        CONTROLLO STREAMING
========================= */
function pauseStreaming(){
        if (!isSending || isPaused) return
        isPaused = true
        writer && writer.write(encoder.encode("!\n")).catch(()=>{})
        worker.postMessage({cmd:'pause'})
}

function resumeStreaming(){
        if (!isPaused) return
        isPaused = false
        writer && writer.write(encoder.encode("~\n")).catch(()=>{})
        worker.postMessage({cmd:'resume'})
}

function stopStreaming(){
        if (!isSending) return
        stopRequested = true
        worker.postMessage({cmd:'stop'})
        clearOkQueue()
}

async function softReset() {
        try {
                await writer.write(new Uint8Array([0x18]))
                await new Promise(r => setTimeout(r, 500))
        } catch (e) {
                console.error("Error:", e)
        }
}

/* =========================
        PROGRESS BAR
========================= */
function updateProgressBar(){
        var bar = document.getElementById('progress-bar')
        if (!bar || totalGCodeLines === 0) return
        bar.style.width = Math.round((sentGCodeLines / totalGCodeLines) * 100) + '%'
}

/* =========================
        SERIAL CONNECTION
========================= */
async function connectSerial(){
        if (isConnected) return
        try {
                if (!port) {
                        var ports = await navigator.serial.getPorts()
                        port = ports[0] || await navigator.serial.requestPort()
                }
                await port.open({baudRate: 115200})
                writer = port.writable.getWriter()
                isConnected = true
                isManualDisconnect = false
                console.log("Connected")
                readSerialData()
                setTimeout(async () => {
                        try {
                                setTimeout(async () => {
                                        //await writer.write(new Uint8Array([0x18]))
                                        await writer.write(encoder.encode("$X\n"))
                                }, 1500)
                        } catch(e) { console.error("Error sending $X:", e) }
                }, 500)
        } catch(e) {
                console.error("Connect fail:", e)
        }
}

async function disconnectSerial(){
        isManualDisconnect = true
        stopPingGRBL()
        clearOkQueue()
        try {
                if (reader) {
                        await reader.cancel()
                        if (readableStreamClosed) await readableStreamClosed.catch(()=>{})
                        reader.releaseLock()
                }
                if (writer) {
                        await writer.close()
                        writer.releaseLock()
                }
                if (port) await port.close()
                isConnected = false
                reader = writer = port = readableStreamClosed = null
        } catch(e) { console.error("Disconnect error:", e) }
}

/* =========================
        READ SERIAL DATA
========================= */
async function readSerialData(){
        if (!port) throw new Error("No port")
        var decoder = new TextDecoderStream()
        readableStreamClosed = port.readable.pipeTo(decoder.writable)
        reader = decoder.readable.getReader()
        var buffer = ''
        try {
                while (true) {
                        var {value, done} = await reader.read()
                        if (done) break; buffer += value
                        var lines = buffer.split(/\r?\n/)
                        buffer = lines.pop()
                        for (var raw of lines) {
                                var line = raw.trim()
                                if (!line) continue
                                if (line === 'ok') {
                                        error2Count = 0
                                        var resolver = okQueue.shift()
                                        if (resolver) {
                                                try {
                                                        resolver()
                                                        console.response("← GRBL:", line)
                                                } catch(e){}
                                        }; continue
                                }                             
                                if (line.startsWith('echo:')) console.warn('[GRBL echo]', line)
                                else if (line.startsWith('[MSG:')) console.info('[GRBL MSG]', line)
                                else if (line.startsWith('error:2')) {
                                        if (lastLineSent && error2Count < 3) {
                                                error2Count++; await writer.write(encoder.encode(lastLineSent))
                                        } else {
                                                console.error("Repeated error:2, skipping line:", lastLineSent)
                                        }
                                }
                                else if (line.startsWith('error:24')){
                                        await writer.write(encoder.encode("$X\n"))
                                        if (isSending && !stopRequested) {
                                                setTimeout(() => worker.postMessage({cmd:'ok'}), 500)
                                        }; continue
                                }
                                else if (line.startsWith('error:')) console.error('[GRBL error]', line)
                                else if (line.startsWith('alarm:')) console.error('[GRBL alarm]', line)
                                else if (line.startsWith('<') && line.endsWith('>')) {
                                        statusListeners.forEach(cb => {try{cb(line)} catch(e){}})
                                        var el = document.getElementById('grbl')
                                        if (!el) return
                                        var parts = line.replace(/[<>]/g, '').split('|')
                                        var formatted = parts.map(part => {
                                                if (part.includes(':')) {
                                                        var [key, value] = part.split(':')
                                                        return `${key.trim()}: ${value.trim()}`
                                                }
                                                return part.trim()
                                        }).join('\n')
                                        el.textContent = formatted
                                }
                        }
                }
        } catch(e) {
                console.error('Serial read error:', e)
                isConnected = false
                try {await port.close()} catch(err){}
        } finally {
                try {reader.releaseLock()} catch(e){}
                if (isManualDisconnect) try {await port.close()} catch(e){}
        }
}

/* =========================
        GRBL PING
========================= */
function startPingGRBL(){
        stopPingGRBL()
        pingInterval = setInterval(() => {
                if (isConnected && writer) {
                        writer.write(encoder.encode("$?\n")).catch(()=>{})
                }
        }, 500)
}

function stopPingGRBL(){
        if (pingInterval) clearInterval(pingInterval)
}

/* =========================
UI BINDINGS
========================= */
document.getElementById('connect').addEventListener('click', connectSerial)
document.getElementById('stop').addEventListener('click', disconnectSerial)
document.getElementById('send').addEventListener('click', streamGCodeWorkerMain)
document.getElementById('pause').addEventListener('click', pauseStreaming)
document.getElementById('resume').addEventListener('click', resumeStreaming)




                                async function sendSingleCommand() {
                                        var cmd = document.getElementById('cmd').value.trim()
                                        if (cmd !== "") {
                                                await sendToGRBL(cmd);
                                                console.log(`Command sent: ${cmd}`)
                                                document.getElementById('cmd').value = ""
                                        }
                                }
                                document.getElementById('cmd').addEventListener('keydown', function (e) {
                                        if (e.ctrlKey && e.key === "Enter") {sendSingleCommand()}
                                })

                                //------ jog
                                async function sendJog({ x = 0, y = 0, z = 0, f = 1000 }) {
                                        var dx = Math.abs(x)
                                        var dy = Math.abs(y)
                                        var dz = Math.abs(z)
                                        var distance = Math.max(dx, dy, dz)
                                        var durationMs = (distance / (f / 60)) * 1000

                                        var jogLine = `$J=G91 G21 X${x} Y${y} Z${z} F${f}\n`
                                        await writer.write(encoder.encode(jogLine))
                                        console.log(`[JOG] ${jogLine.trim()}`)

                                        await new Promise(r => setTimeout(r, durationMs + 100))

                                        await writer.write(encoder.encode("G90\n"))
                                        await writer.write(encoder.encode("?\n"))
                                }
                                document.addEventListener("keydown", async function (e) {
                                        if (!e.ctrlKey || !isConnected || isSending || isPaused) return
                                        e.preventDefault()

                                        var step = e.shiftKey ? 10 : 1
                                        var feed = 1000

                                        if (e.key === "ArrowUp")        await sendJog({y: step, f: feed })
                                        if (e.key === "ArrowDown")      await sendJog({y: -step, f: feed})
                                        if (e.key === "ArrowLeft")      await sendJog({x: -step, f: feed})
                                        if (e.key === "ArrowRight")     await sendJog({x: step, f: feed })
                                        if (e.key === "PageUp")         await sendJog({z: step, f: 500  })
                                        if (e.key === "PageDown")       await sendJog({z: -step, f: 500 })
                                })
                                document.addEventListener("keydown", async function (e) {
                                        if (!isConnected || !e.shiftKey) return

                                        var overrideChar = null

                                        switch (e.key.toLowerCase()) {
                                                case "f": overrideChar = "+"; break // feed +
                                                case "g": overrideChar = "-"; break // feed -
                                                case "r": overrideChar = "="; break // feed reset

                                                case "s": overrideChar = "^"; break // spindle +
                                                case "d": overrideChar = "v"; break // spindle -
                                                case "x": overrideChar = "~"; break // spindle reset

                                                case "z": overrideChar = ">"; break // rapid +
                                                case "a": overrideChar = "<"; break // rapid -
                                                case "q": overrideChar = "|"; break // rapid reset
                                        }

                                        if (overrideChar) {
                                                await writer.write(encoder.encode(overrideChar))
                                                console.log(`[OVERRIDE] ${overrideChar}`)
                                                e.preventDefault()
                                        }
                                })

                                async function sendToGRBL(command) {
                                        return new Promise(async (resolve, reject) => {
                                                if (!writer) {
                                                        reject('Serial port writer not available'); return
                                                }
                                                var timeoutId = setTimeout(() => {
                                                        reject('Timeout: No OK response from device')
                                                }, OK_TIMEOUT)
                                                enqueueOkResolver(() => {
                                                        clearTimeout(timeoutId); resolve()
                                                })
                                                try {
                                                        var data = new TextEncoder().encode(command + '\n')
                                                        await writer.write(data)
                                                } catch (e) {
                                                        clearTimeout(timeoutId); reject(e)
                                                }
                                        })
                                }
                        </script>                                 
                </div>

                <script>                                
                        document.addEventListener('keydown', function(event) {
                                if (event.ctrlKey && event.key === 'Delete') {
                                        clearCNVS()
                                        if (imgInstance) {canvas.remove(imgInstance)}
                                        cancBool = true; objNumber = 0
                                }
                                else if (event.ctrlKey && event.key === 'i') {
                                        event.preventDefault()
                                        document.getElementById('input').click()
                                }
                                else if (event.ctrlKey && event.key === '+') {
                                        event.preventDefault()
                                        updateZoom(zoomLevel - zoomFactor)
                                }
                                else if (event.ctrlKey && event.key === '-') {
                                        event.preventDefault()
                                        updateZoom(zoomLevel + zoomFactor)
                                }
                                else if (event.ctrlKey && event.key === 'r') {
                                        event.preventDefault()
                                        resetZoom()
                                }
                                else if (event.ctrlKey && event.key === 'm') {
                                        event.preventDefault()
                                        resetCAMERA()
                                }
                                else if (event.ctrlKey && event.key === 'g') {
                                        event.preventDefault();
                                        for (var i = 0; i < interactiveGuides.length; i++) {
                                                var guide = interactiveGuides[i];
                                                canvas.remove(guide.horizontalLine)
                                                canvas.remove(guide.verticalLine)
                                                canvas.remove(guide.intersectionCircle)
                                        }
                                        interactiveGuides = [];
                                        canvas.renderAll();
                                }
                                else if (event.altKey && event.key === 'a') {
                                        event.preventDefault()
                                        addPOLYLINE()
                                }
                                else if (event.altKey && event.key === 's') {
                                        event.preventDefault()
                                        addPOLYGON(20, 100, 100, 30)
                                }
                                else if (event.altKey && event.key === 'd') {
                                        event.preventDefault()
                                        addTEXT('roboto_b', 100, 100, 100, 'test')
                                }
                                else if (event.altKey && event.key === 'f') {
                                        event.preventDefault()
                                        addRECTinteractive()
                                }    
                                else if (event.altKey && event.key === 'g') {
                                        event.preventDefault()
                                        addELLIPSEinteractive()
                                }       
                        })


                        var wakeLock = null
                        async function requestWakeLock() {
                                try {
                                        wakeLock = await navigator.wakeLock.request("screen")
                                        console.log("Wake Lock attivato")
                                        wakeLock.addEventListener("release", () => {
                                                console.log("Wake Lock rilasciato")
                                        })
                                } catch (err) {
                                       console.error(`${err.name}, ${err.message}`)
                                }
                        }; requestWakeLock()

                        function isRunningAsPWA() {
                                return (
                                        window.matchMedia('(display-mode: standalone)').matches || 
                                        window.navigator.standalone === true                     
                                )
                        }
                        window.addEventListener("DOMContentLoaded", () => {
                                if (!isRunningAsPWA()) {
                                        document.getElementById("pwa-warning").style.display = "block"
                                }
                        })                                                 
                </script>                                 

                <div id="pwa-warning" style="
                        display:none; position:fixed; bottom:20px; left:50%; transform:translateX(-50%);
                        background:#000; border:1px solid #3c3c3c; padding:15px 20px; font-size:12px; z-index:9999;
                ">⚠️ for stable background execution, install the PWA from your browser</div>
                                  
                <div id="splash" style="z-index:9999; position:absolute; width:100%; height:100%; left:50%; transform:translateX(-50%)">
                        <script>                                    

                                setTimeout(() => {
                                        $("#splash").load("../HTML/anim.html", function() {
                                                setTimeout(() => {
                                                        $("#splash").addClass("fade");
                                                        setTimeout(() => { $("#splash").remove(); }, 2000)
                                                }, 3000)
                                        })
                                        setTimeout(() => {
                                                $("#pwa-warning").fadeOut(2000)
                                                setWorkArea(); TAOpen()
                                        }, 5000)
                                }, 0)
                        </script>   
                </div>                 
        </body>             
</html>  

<!--

-->

