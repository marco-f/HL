<!-- /HTML/main.html -->
<!DOCTYPE html>
<html xml:lang="en" lang="en">
        <head>
                <!-- Meta tags to prevent caching -->
                <meta http-equiv="cache-control" content="max-age=0">
                <meta http-equiv="cache-control" content="no-cache">
                <meta http-equiv="expires" content="-1">
                <meta http-equiv="expires" content="Tue, 01 Jan 1980 11:00:00 GMT">
                <meta http-equiv="pragma" content="no-cache">
                <meta charset="UTF-8">

                <title>HobbyLaser!</title>           

                <!-- favicon -->
                <link rel="icon" type="image/png" href="../IMG/lsr.svg">

                <link rel="stylesheet" href="https://necolas.github.io/normalize.css/8.0.1/normalize.css">

                <!-- style -->    
                <link rel="stylesheet" href="../CSS/drawing.css">
                <link rel="stylesheet" href="../CSS/jquery.css">

                <!-- third parties -->
                <script src="../JS/src/jquery.js"></script>
                <script src="../JS/src/jquery-ui.js"></script>
                <script src="../JS/src/fabric.js"></script>               
                <script src="../JS/ace/ace.js"></script>                
                <script src="../JS/src/clipper.js"></script>         
                <script src="../JS/src/opentype.js"></script> 
                <script src="../JS/src/potrace.js"></script>
                <script src="../JS/src/polyfill.js"></script>
                <script src="../JS/src/drawing.js"></script>
                <script src="../JS/src/ruler.js"></script>
                <script src="../JS/src/dxf.js"></script>

                <!-- three.js -->
                <script src="../JS/three/three.js"></script>
                <script src="../JS/three/gcode-model.js"></script>
                <script src="../JS/three/OrbitControls.js"></script>
        </head>

        <style>
                * {box-sizing: border-box}

                html, body {width:100%; height:auto; margin:0; color:#fff}        
                .hidden-cursor {cursor: none} 
                @font-face {
                        font-family: test-family;
                        src: url("FONT/Roboto-Black.ttf")
                }   
         
                ::-webkit-scrollbar {width:7px}
                ::-webkit-scrollbar-thumb {
                        background:rgba(0,0,0,0);
                        border-radius: 4px; cursor:pointer
                }

                ::selection {color:white; background: rgb(25,25,25)}  

                .center_H{position:absolute; text-align: center}  
                
                .bs {
                        position:absolute;
                        width: 100px; height: 20px;
                        color:#fff; font-size:10px; 
                        border:none; background:none; outline:none
                }
                .btImg {
                        position:absolute;
                        width: 100px; height: 20px;
                        color:#fff; cursor:pointer; font-size:10px;
                        border: none; background:none; outline:none
                }
                .btImg:hover {color:#2f81f7}                   

                #_2D {
                        overflow-x:hidden;
                        position: absolute;
                        background:#080808;
                        top: 20px; left: 0; right: 0;
                        width: 100%; height: 100%; 
                }

                #n_Line {
                        outline:none;user-select: none;
                        position:absolute; resize:none;
                        font-size:18px; line-height:0.72; 
                        border: 0; text-align: left;
                        overflow:hidden; width:30px;
                        color:gray;top:35px; height:100%; 
                        background:transparent}
                #n_Line:focus-visible,

                #editor {position:absolute;bottom:0; top:10px; border: 0;
                        left:0; right:0; line-height: 1.2;background:#050505}
                .ace_editor *{font-size: 11px !important; color:gray}
                .ace_editor {border: none !important}
                .ace_scrollbar {display: none !important}
                .ace_editor .ace_marker-layer .ace_selection {background:#202020}
                .ace_editor .ace_cursor {color: red}
                .ace_tooltip {display: none !important} 
                #TA.closed {transform: translateX(100%)}                   

                a {color:gray}
                                 
                #progress-container {
                        position:absolute;     
                        width: 100%; bottom:0px;
                        background-color:transparent;
                        height: 2px; margin-top: 0px;
                }
                #progress-bar {
                        width: 0%; height: 100%;
                        background-color: #2f81f7;
                }

                .fade_2 {opacity: 0; transition: opacity 2s ease-in-out}

                #crud-wrapper {
                        position: absolute;
                        width:450px; top:50px; right:0px; left:30px
                }
                #crud {
                        top:30px; left:20px;
                        flex-direction: column;            
                        padding: 2px 2px 2px 0px;            
                        display:flex; max-width:440px;    
                        position:relative; overflow-y:auto;
                }
                #fileList {
                        width: 100%;
                        list-style: none;
                        padding: 0; margin: 0;
                }
                #fileList li {margin-bottom:10px;
                        font-size:12px;
                        display: flex;
                        align-items: center;
                        padding: 2px; width: 100%;
                        justify-content: space-between;    
                }
                .button-container {
                        display: flex; gap: 10px;
                        justify-content: flex-end;    
                }

                #svgCont .custom-svg {
                        width: 300px; height: 200px;
                        border: 1px solid #3c3c3c;
                        box-sizing: border-box;
                        position: absolute;
                        padding: 10; z-index:500; top: 100px; left:100px
                }

                .alert-box {
                        z-index: 1000; display: flex;width:60%;
                        position: fixed; top: 40%; left: 50%; top:50%;
                        transform: translate(-50%, -50%);
                        background: #101010; padding: 20px;
                        border: 1px solid #444; border-radius: 8px;
                        align-items: center;  text-align: center;
                }
                .alert-content {
                        font-size:14px; font-weight:bold; width:100%;
                }
                .alert-img {
                        position: relative;
                        background: transparent;
                        height: 120px; width: 100px;
                }
                .disclaimer-text {
                        font-size: 12px; width: 80%;
                        margin: 0 auto; text-align: center;
                }
                .btAlert {
                        cursor: pointer; appearance: none; outline: 0;
                        border:1px solid gray; width:177px; background:#101010;
                        text-align: center; height: 25px; color:gray;
                        font-weight: 250; font-size: 12px; border-radius:15px;
                        margin: 0; position: relative;
                }                        
                .btAlert::before {
                        content: ""; position: absolute; left: 0;
                        top: 0; width: 100%; height: 100%;
                        border-radius: 30px; border: 1px solid white;
                        box-sizing: border-box; clip-path: inset(0 100% 0 0);
                        transition: clip-path 0.3s ease-in;color:#fff
                }
                .btAlert:hover::before {clip-path: inset(0 0 0 0)}
                .btAlert:hover {background: #050505; color:#fff}
                .btAlert:focus {
                        background: #0a0a0a;
                        color: #2f81f7;
                        box-shadow: 0 0 0 2px #ffffff44;
                }
                .btAlert:focus::before {
                        clip-path: inset(0 0 0 0);
                }

                
                /*@media (max-width: 1400px) {
                        #panel {
                                left: 50px;  right: 50px;
                        }
                }
                @media (max-width: 1200px) {
                        #panel {
                                left: 20px;  right: 20px;
                        }
                }
                @media (max-width: 800px) {
                        #panel {
                                align-items: center;
                                flex-direction: column;
                                height: auto; display: flex; 
                                left: 5vw; right: 5vw; padding: 10px;
                        }
                        #preview {
                                width: 100%; height: auto; margin: 10px 0;    
                        }
                        #first {
                                flex-direction: column;
                        }
                        .right-column { 
                                width: 100%;  margin-left: 0; margin-top: 10px;
                        }
                        #third {
                                width: 100%; height: 150px; margin: 10px 0;
                        }
                }*/

                .panel {
                        height: 60vh; aspect-ratio: 1 / 1; background: #101010;
                        border: 1px solid #3c3c3c; flex-shrink: 0; z-index:500; 
                }              

                #tbScroll {
                        overflow: auto; max-height: calc(100% - 20px) !important; 
                }
                table {
                        z-index:500;
                        max-width: 100%; font-size: 12px;
                        border-collapse: collapse;
                        max-height: 100% !important; 
                }
                th {background: transparent; padding-left: 10px; font-size: 12px}
                #td:first-child {padding-right: 30px}

                .close-btn {
                        font-weight: bold; font-size: 18px;
                        width:30px; height:30px; background-color:#080808;
                        position:absolute; top:10px; right:10px; z-index:500;
                        text-align:center; line-height:26px; cursor: pointer;        
                        border:2px solid #3c3c3c; color:white; border-radius:50%
                }
                .close-btn:hover {background-color: #1a1a1a}

                .btRD {
                        display: flex;align-items: center; 
                        justify-content:center;color: white;        
                        cursor: pointer; border-radius: 50%;
                        border: 1px solid #3c3c3c; font-size: 15px; outline:none;       
                        background:#080808; width:16px; height:16px; padding-bottom:2px           
                }
                .btRD:focus {outline:none; color:#f0f}
                .btRD:disabled {
                        opacity: 0.4; cursor: not-allowed;    
                        color: #888; background: #222; border-color: #555
                }                             
        </style>
                                                              
        <body>   
                <!-- html HEAD -->
                <div id="head" style="background:#080808;
                        z-index:9; border-bottom:0px solid #3c3c3c;
                        width:100%; height:40px; position:fixed;
                        top:0px; border-top:0px solid #11e1e">

                        <div class="bs" style="top:13px; width:200px; left:30px" onclick="">
                                <img src="../IMG/HLB.png" width="200px" height="16px"/>
                        </div>

                        <button class="btImg" style="cursor:pointer; font-size:10px;
                                top:10px; right:100px" onclick="window.location.reload(true)">refresh</button>
                        <!-- UserGUIDE -->
                        <button class="btImg" style="cursor: pointer; font-size:10px; top:10px; right:20px"
                        onclick="window.open('https://github.com/marco-f/HL/wiki/Home', '_blank')">
                                <img src="../IMG/GH.svg" width="17px" style="cursor:pointer"/>
                        </button>
                                               
                        <input style="display:none" type="file" id="input"/>

                        <div id="progress-container">
                                <div id="progress-bar"></div>
                        </div>                      
                </div>
                                  
                <div id="_2D">
                        <script>
                                $("#_2D").load("../HTML/rend.html")
                        </script>
                </div>

                <button style="position:fixed; z-index:100; left:1px; top:40px; width:18px; height:20px; border:0; cursor:pointer;
                        background:#101010; border-right:1px solid #888; border-bottom:1px solid #888;"
                        onclick="createInteractiveGuide()"></button>

                <div id="horizontalLabel" class="label"></div>
                <div id="verticalLabel" class="label"></div>



                <div id="OV" style="z-index:400; border:0px solid #3c3c3c; display:none;
                        position:fixed; width:101%; height:100%; left:0; top:40px; background:transparent">
                </div>                            


                <!-- editor (scriptArea) -->
                <div id="TA" style="border-left:1px solid #3c3c3c; z-index:150; resize: horizontal; cursor: ew-resize; transform: translateX(100%);
                        position: fixed; width: 40%; height:100%; right: 0; top: 60px; background: #050505; transition: transform 0.5s ease">

                        <!-- Textarea for line indicators (read-only) -->
                        <textarea id="n_Line" style="right: 0px; top: 10px; height: calc(100% - 150px); overflow: hidden" wrap="off" readonly></textarea>

                        <!-- Div container for the Ace editor -->
                        <div id="editor" class="language-javascript" style="position: absolute; color: white; width: calc(50% - 50px); height: calc(100% - 150px)"></div>

                        <script>
                                var tooltip = document.getElementById("textTooltip")               
                                var cE = document.getElementById('editor');
                                cE.addEventListener("contextmenu", function(e) {
                                        e.stopPropagation()
                                })

                                var nL = document.getElementById('n_Line')
                                nL.style.fontSize = '18px'
                                nL.style.pointerEvents = "none"

                                var editor = ace.edit("editor")
                                var taClosed = true

                                function updateLayout() {
                                        var taWidth = $("#TA").width()
                                        var editorWidth = taWidth - 30
                                        var windowHeight = $(window).height()
                                        var footerHeight = $("#footer").height()
                                        var editorHeight = windowHeight - footerHeight - 90 ///////////////////////////////////////////////////////////////

                                        $("#editor").width(editorWidth).height(editorHeight)
                                        $("#n_Line").height(editorHeight)

                                        if (typeof editor.resize === 'function') {
                                                editor.resize();
                                        }

                                        if (taWidth <= 50) {$("#n_Line").hide()}
                                        else {$("#n_Line").show()}
                                }

                                function TAClose() {
                                        if (!taClosed) {
                                                $("#TA").css("transform", "translateX(100%)");
                                                taClosed = true;
                                        }
                                }

                                function TAOpen() {
                                        if (taClosed) {
                                                $("#TA").css("transform", "translateX(0)");
                                                taClosed = false;
                                                setTimeout(updateLayout, 500);
                                        }
                                }

                                $("#TA").resizable({
                                        handles: 'w', minWidth: 0,
                                        maxWidth: $(window).width() - 250,
                                        resize: function(event, ui) {
                                                var newWidth = ui.size.width
                                                var editorWidth = newWidth - 30
                                                $("#editor").width(editorWidth)
                                                if (typeof editor.resize === 'function') {
                                                        editor.resize()
                                                }
                                                if (newWidth <= 50){$("#n_Line").hide()}
                                                else {$("#n_Line").show()}
                                        },
                                        stop: function(event, ui){
                                                var newWidth = ui.size.width;
                                                if (newWidth <= 50 && !taClosed) {
                                                        TAClose();
                                                }
                                        }
                                })

                                $(window).on('resize', updateLayout)

                                editor.setTheme("ace/theme/pastel_on_dark")
                                editor.session.setMode("ace/mode/javascript")
                                editor.getSession().setUseWrapMode(true)
                                editor.getSession().setWrapLimitRange(null, null)
                                editor.setOption("scrollPastEnd", 0)
                                editor.setOption("showGutterTooltip", false)
                                editor.setBehavioursEnabled(false)
                                editor.setOptions({
                                        fontFamily: "'Courier New', monospace"
                                })
                                editor.getSession().setUseWorker(false)
                                editor.session.clearAnnotations()

                                editor.getSession().on('change', function() {
                                        end_line()
                                })

                                editor.setValue(`//uncomment and after ctrl + enter
function simpleGear(numberOfTeeth, radius, heightOfTooth){
        var paths = [[]];    
        var centerX = 30; 
        var centerY = 30;
        var radiusMinusTeeth = radius - heightOfTooth;

        var distancesOfVerticesFromCenter = [
                radius, radius,
                radiusMinusTeeth,
                radiusMinusTeeth,
        ];
        var verticesPerTooth = distancesOfVerticesFromCenter.length;
        var numberOfVertices = numberOfTeeth * verticesPerTooth;

        for (var v = 0; v < numberOfVertices; v++) {
                var angleInRadians = (Math.PI * 2 * v) / numberOfVertices;
                var distanceOfVertexFromCenter = distancesOfVerticesFromCenter[v % verticesPerTooth];

                var drawPosX = centerX + distanceOfVertexFromCenter * Math.cos(angleInRadians);
                var drawPosY = centerY + distanceOfVertexFromCenter * Math.sin(angleInRadians);

                paths[0].push({ X: drawPosX, Y: drawPosY });        
        }
        paths[0].push(paths[0][0]); return use(paths);
}
simpleGear(15, 20, 4).nc
//POLYLINE("M10 10 L40 10 L40 40 L10 40 L10 10 Z").tab(2,4).nc
`)
                                editor.clearSelection()
                                editor.moveCursorTo(0, 0);

                                function end_line() {
                                        var totalLines = editor.getSession().getLength(),
                                                outarr = [];
                                        for (var x = 0; x < totalLines; x++) {
                                                outarr[x] = '↩';
                                        }
                                        nL.value = outarr.join('\n')
                                }

                                function appToEdt(text) {
                                        var session = editor.getSession()
                                        var oldText = session.getValue()
                                        session.setValue(oldText + text)
                                }

                                function autoScroll() {
                                        var session = editor.getSession()
                                        var length = session.getLength()
                                        editor.scrollToLine(length, true, true, function() {})
                                }

                                editor.getSession().on('change', function() {
                                        autoScroll()
                                })

                                function remToEdt(searchString) {
                                        var content = editor.getValue();
                                        var regex = new RegExp(searchString + "\\([^)]*\\)", "g")
                                        var lines = content.split("\n"),
                                                modifiedLine = -1;
                                        for (var i = 0; i < lines.length; i++) {
                                                if (regex.test(lines[i])) {
                                                        modifiedLine = i; break
                                                }
                                        }
                                        var updatedContent = content.replace(regex, "")
                                        editor.setValue(updatedContent, -1)
                                        if (modifiedLine !== -1) {
                                                editor.gotoLine(modifiedLine + 2, 0, true)
                                        }; editor.focus()
                                }

                                editor.commands.addCommand({
                                        name: "executeCommand",
                                        bindKey: {win: "Ctrl-Enter", mac: "Command-Enter"},
                                        exec: function(editor) {
                                                var command = editor.getValue().trim()
                                                try { runSCRIPT() }
                                                catch (e){ console.error("error", e) }
                                        }
                                })
   

                                var runSCRIPT = () => {
                                        //try {
                                                clearCNVS()
                                                var userCode = editor.getValue()
                                                var content = edtContent(userCode)
                                                if (cancBool == true){
                                                        canvas.remove(imgInstance)
                                                }
                                                pts = eval(content);
                                                tempGuideLines = interactiveGuides
                                                for (var i = 0; i < tempGuideLines.length; i++){
                                                        var guidePair = tempGuideLines[i]
                                                        canvas.add(guidePair.verticalLine).bringToFront()                                        
                                                        canvas.add(guidePair.horizontalLine).bringToFront()
                                                        canvas.add(guidePair.intersectionCircle).bringToFront()                                       
                                                }
                                                cancBool = false
                                        //} catch(error) {console.error(error)}
                                }
                        </script>
                </div>

                <!-- Footer container (acts as a control panel and log area) -->
                <div id="footer" style="z-index:300; cursor:default; font-family:'Monospace'; font-size:9px; overflow: hidden; left:0;
                position:fixed; bottom:0px; width:100%; height:200px; background:#080808; border-top:2px solid #000; color:#ffffff">

                        <!-- Console log display area -->
                        <div id="cnsLog" class="center_H" style="position: absolute; overflow-x: hidden; background:#050505; line-height:1.5;
                        font-size:10px; border-top:1px solid #3c3c3c; color:gray; top:0px; left:0px; width: 100%; height: calc(100% - 25px)">
                                <!--p id="cnsl" style="position:absolute; top:-5px; right:20px; font-size:10px">>_ ConsoleLog</p-->
                        </div>

                        <!-- JavaScript code -->
                        <script>
                                function ftr() {
                                        var previousHeight = 80

                                        function updateLayout() {
                                                var footerHeight = $("#footer").height()
                                                var windowHeight = $(window).height()
                                                var desiredH = windowHeight - footerHeight + 20
                                                $("#_2D").height(desiredH);
                                        }

                                        FTRClose = function () {
                                                var currentHeight = $("#footer").height()
                                                if (currentHeight > 80) {
                                                        previousHeight = currentHeight
                                                        $("#footer").height(120)
                                                        $("#footer").css('top', 'calc(100% - 80px)')
                                                        updateLayout()
                                                }
                                        }

                                        FTROpen = function () {
                                                $("#footer").height(previousHeight)
                                                $("#footer").css('height', `80px)`)
                                                updateLayout()
                                        }

                                        $("#footer").resizable({
                                                handles: 'n',
                                                minHeight: 80,
                                                maxHeight: 600,
                                                resize: updateLayout
                                        });

                                        $(window).on('resize', updateLayout)
                                        $(window).trigger('resize')                                
                                }; ftr()

                                var cnsLog = document.getElementById('cnsLog')
                                function logging() {
                                        var MAX_LOG_LINES = 200
                                        var logBuffer = []
                                        var bufferFlushInterval = 200  // ms

                                        function customLog(type, color, ...args) {
                                                var  t = new Date()
                                                var  hh = String(t.getHours()).padStart(2, '0')
                                                var  mm = String(t.getMinutes()).padStart(2, '0')
                                                var  ss = String(t.getSeconds()).padStart(2, '0')
                                                var  time = `${hh}:${mm}:${ss}&nbsp;&nbsp;`

                                                var output = ''
                                                args.forEach(arg => {
                                                        output += `<span style="color:${color}">`
                                                        if (arg instanceof Error) {
                                                                output += `<b>${arg.name}: ${arg.message}</b><br>`
                                                        } else if (typeof arg === 'object') {
                                                                output += JSON.stringify(arg, null, 2)
                                                        } else {
                                                                output += arg
                                                        }
                                                        output += '</span>&nbsp;'
                                                })

                                                var html = `<br>
                                                        <span style="color: rgb(60,60,60); line-height:0.2">${"&nbsp;&nbsp;" + time}</span>
                                                        <span style="color: gray; font-weight:bold; line-height:0.2">${"&nbsp;&nbsp;" + type.toUpperCase()}</span>
                                                        <span style="color: red; left:20; line-height:0.2"> >>> </span>
                                                        ${output}`

                                                logBuffer.push(html)
                                        }

                                        function flushLogBuffer() {
                                                if (logBuffer.length === 0) return
                                                var html = logBuffer.join('')
                                                cnsLog.insertAdjacentHTML('beforeend', html)
                                                cnsLog.scrollTop = cnsLog.scrollHeight
                                                logBuffer = []
                                        }

                                        function trimLogLines() {
                                                var children = cnsLog.children
                                                var excess = children.length - MAX_LOG_LINES
                                                for (var i = 0; i < excess; i++) {
                                                        cnsLog.removeChild(children[0])
                                                }
                                        }

                                        console.log = (...args) => customLog('log', '#73abfb', ...args)
                                        console.warn = (...args) => customLog('warn', '#c2c24c', ...args)
                                        console.info = (...args) => customLog('info', '#a7cafc', ...args)
                                        console.error = (...args) => customLog('error', '#b3d5e0', ...args)
                                        console.debug = (...args) => customLog('debug', '#ffffff', ...args)
                                        console.response = (...args) => customLog('response', '#808080', ...args)
                                        console.gcode = (msg, color = '#fff') => {customLog('gc', color, msg)}

                                        console.log('ready ...')
                                        setInterval(flushLogBuffer, bufferFlushInterval)
                                        setInterval(trimLogLines, bufferFlushInterval * 25)
                                }; logging()

                                var scrollTimeout
                                var observer = new MutationObserver(() => {
                                        if (scrollTimeout) clearTimeout(scrollTimeout)
                                        scrollTimeout = setTimeout(() => {
                                                cnsLog.scrollTop = cnsLog.scrollHeight
                                        }, 100)
                                }); observer.observe(cnsLog, {childList: true})

                                var objNumber = 0;
                                function addToConsole() {
                                        objNumber = canvas.getObjects().length - 1
                                        console.log("HL obj on canvas: " + objNumber)
                                }
                        </script>
                </div>

                <!-- Bottom fixed control bar -->
                <div id="srv" style="z-index:900; position:fixed; bottom:0px; width:100%; height:
                25px; left:0px; font-size:11px; background:#080808; border-top:1px solid #2f81f7">

                        <!-- Position indicators -->
                        <p id="mPos" style="position:fixed; color:gray; bottom:-7px; left: 20px; font-size:11px">pos (x:, y:)</p>
                        <p id="cPos" style="position:fixed; color:gray; bottom:-7px; left:200px; font-size:11px">pos (row:, col:)</p>
                        <p id="wa" style="position:fixed; color:gray; bottom:-7px; left:380px; font-size:11px">WorkArea (w:, h:)</p>
                        <p id="fps" style="position:fixed; color:gray; bottom:-7px; right:20px; width:70px; font-size:11px"></p>

                        <p style="position:fixed; color:gray; bottom:-7px; right:300px; width:70px; font-size:11px; cursor:pointer" onclick="TAOpen()">OpenTA</p>

                        <!-- Clear Log and Reset Swap buttons with onclick events -->
                        <p style="position:fixed; color:gray; bottom:-7px; right:100px; width:150px; font-size:11px; cursor:pointer"
                        onclick="cnsLog.innerHTML=''; console.log('ready ...')">< Clear Log ></p>

                        <script>
                                var pos = document.getElementById("mPos")
                                function mousePos(ev) {
                                        var dpi = window.devicePixelRatio * 96
                                        posX = (ev.clientX * (25.4 / dpi)).toFixed(0) - 5
                                        posY = (ev.clientY * (25.4 / dpi)).toFixed(0) - 15
                                        pos.innerHTML = 'mPos (x: ' + posX + ', y: ' + posY + ')'
                                }; document.addEventListener('mousemove', mousePos, false)

                                var cur = document.getElementById("cPos")
                                function cursorPos(ev) {
                                        var cursorPosition = editor.getCursorPosition()
                                        row = cursorPosition.row + 1
                                        col = cursorPosition.column
                                        cur.innerHTML = 'cPos (row: ' + row + ', col: ' + col + ')'
                                }; document.addEventListener('mousemove', cursorPos, false)

                                var wa = document.getElementById("wa")
                                function calculateWASize() {
                                        wa.innerHTML = 'WorkArea (w: ' + dWidth + ',h: ' + dHeight + ')'
                                }; calculateWASize()

                                var fpsElement = document.getElementById('fps')
                                var frame = 0, startTime = performance.now()
                                function calculateFPS() {
                                        frame++
                                        var now = performance.now();
                                        if (now - startTime > 1000) {
                                                var fps = (frame / ((now - startTime) / 1000)).toFixed(2)
                                                fpsElement.textContent = `${fps} fps`
                                                frame = 0; startTime = now
                                        }; requestAnimationFrame(calculateFPS)
                                }; calculateFPS()
                        </script>
                </div>

                <!-- GCode Section -->
                <div id="GCC" style="z-index:350; position:absolute; background:#101010; width:780px; height:330px; 
                left: 50%; top: 50%; transform: translate(-50%,-50%); border: 1px solid #3c3c3c; display:none">
                        <h3 style="text-align:center">< GCODE GENERATOR ></h3>
                        <!--button class="bs" style="top:20px; right:-20px; cursor:pointer" onclick="toggleGCconv()">X</button-->       
                               
                        <div class="buttons-container" style="top:70px; width:100%">
                                <div style="width:auto; height:auto; margin:0 auto; position:relative; display:flex; align-items:center; gap:6px">
                                        <span class="txtInp" style="background:transparent; border:0; cursor:default; width:50px; text-align:center">MODE</span>
                                        <button class="btRD" id="m_1" onclick="setMODE('m_1')">●</button> cutter
                                        <button class="btRD" id="m_2" onclick="setMODE('m_2')">●</button> engrave                  
                                        <button class="btRD" id="m_3" onclick="setMODE('m_3')">●</button> image
                                        <br>
                                        <span class="txtInp" style="background:transparent; border:0; cursor:default; width:70px; text-align:center">&nbsp;&nbsp;INFILL</span>
                                        <button class="btRD" id="m_4" onclick="setFILL('m_4')">●</button> hexagon
                                        <button class="btRD" id="m_5" onclick="setFILL('m_5')">●</button> grid                  
                                        <button class="btRD" id="m_6" onclick="setFILL('m_6')">●</button> triangle
                                </div>
                        </div>
                                          
                        <div id="t_1" class="buttons-container" style="top:120px">
                                <span class="txtInp" style="background:transparent; border:0; cursor:default; width:70px">min POWER(%)</span>
                                <input class="txtInp" type="text" id="_02" placeholder="set power" maxlength="4" value="0"/>

                                <span class="txtInp" style="background:transparent; border:0; cursor:default; width:50px;">max POWER(%)</span>
                                <input class="txtInp" type="text" id="_03" placeholder="set power" maxlength="4" value="255"/>

                                <span class="txtInp" style="background:transparent; border:0; cursor:default; width:50px">speed TRAVEL</span>
                                <input class="txtInp" type="text" id="_04" placeholder="radius" value="1000"/>

                                <span class="txtInp" style="background:transparent; border:0; cursor:default; width:50px;">speed LASER</span>
                                <input class="txtInp" type="text" id="_05" placeholder="radius" value="600"/>
                                          
                                <span class="txtInp" style="background:transparent; border:0; cursor:default; width:50px">n° PASS.</span>
                                <input class="txtInp" type="text" id="_06" placeholder="n° passes" value="1"/>
                        </div>
                        <div id="t_2" class="buttons-container" style="top:160px">
                                <span class="txtInp" style="background:transparent; border:0; cursor:default; width:70px">rowsPerMM</span>
                                <input class="txtInp" type="text" id="_07" placeholder="rows/mm" maxlength="4" value="3"/>

                                <span class="txtInp" style="background:transparent; border:0; cursor:default; width:50px">Z-AXIS</span>
                                <input class="txtInp" type="text" id="_08" placeholder="inc. Z" maxlength="4" value="0"/>

                                <span class="txtInp" style="background:transparent; border:0; cursor:default; width:50px">Z-MAX</span>
                                <input class="txtInp" type="text" id="_09" placeholder="inc. Z" maxlength="4" value="1"/>                                

                                <span class="txtInp" style="background:transparent; border:0; cursor:default; width:50px">&nbsp;air&nbsp;
                                ASSIST</span><input class="txtInp" type="text" id="_10" placeholder="set air" maxlength="4" value="0"/>
                               
                                <span class="txtInp" style="background:transparent; border:0; cursor:default; width:50px">Acc. (mm/s²)</span>
                                <input class="txtInp" type="text" id="_11" placeholder="inc. Z" maxlength="4" value="500"/>
                        </div>

                        <div id="t_3" class="buttons-container" style="top:220px; width:100%">
                                <div id="d_1" style="width:auto; height:auto; margin:0 auto; position:relative; display:flex; align-items:center; gap:6px">
                                        add BB<button class="btRD" id="m_7" onclick="toggleBB()">●</button>&nbsp;&nbsp;
                                
                                        <span class="txtInp" style="background:transparent; border:0; cursor:default; width:50px">toGCODE</span>
                                        <button class="btTool" onclick="obj2gc()">create</button>
                                </div>
                        </div>

                        <p class="bs" style="width:100%; top:290px; text-align:center">* default row filling (no fill selected)</p>                 
                               
                        <script>                       
                                var gcBool = false
                                function toggleGCconv() {
                                        if (!gcBool) {
                                                $('#GCC').show(); gcBool = true; GCSenderHide(); 
                                                updateFillButtons()
                                                setTimeout(function() {
                                                        mode = 'cutter'; document.getElementById("m_1").focus()
                                                }, 0)
                                        } else {$('#GCC').hide(); gcBool = false}
                                }

                                var mode = 'cutter'
                                var setMODE = function(activeId) {
                                        var button1 = document.getElementById('m_1')
                                        var button2 = document.getElementById('m_2')
                                        var button3 = document.getElementById('m_3')

                                        button1.blur(); button2.blur(); button3.blur()
                                        document.getElementById(activeId).focus()
                                        if (activeId === 'm_1') {mode = 'cutter'; updateFillButtons()}
                                        else if (activeId === 'm_2') {mode = 'engrave'; updateFillButtons()}
                                        else if (activeId === 'm_3') {mode = 'image'; updateFillButtons()}
                                }
                                var inFill = ''
                                var setFILL = function(activeId) {
                                        if(tabBool) return
                                        var button4 = document.getElementById('m_4')
                                        var button5 = document.getElementById('m_5')
                                        var button6 = document.getElementById('m_6')

                                        button4.blur(); button5.blur(); button6.blur()

                                        if (activeId === 'm_4') {button4.focus(); inFill = 'hex'}
                                        else if (activeId === 'm_5') {button5.focus(); inFill = 'grid'}
                                        else if (activeId === 'm_6') {button6.focus(); inFill = 'tri'}
                                }
                                document.addEventListener('DOMContentLoaded', function() {
                                        updateFillButtons()
                                })                             
                                function updateFillButtons() {
                                        if (tabBool) {
                                                $('#m_2, #m_3, #m_4, #m_5, #m_6').prop('disabled', true)
                                                return
                                        }      
                                        if (mode == 'cutter' || mode == 'image') {
                                                document.getElementById('m_4').disabled = true
                                                document.getElementById('m_5').disabled = true
                                                document.getElementById('m_6').disabled = true
                                                document.getElementById('m_2').disabled = false
                                                document.getElementById('m_3').disabled = false
                                        }
                                        else if (mode == 'engrave') {
                                                document.getElementById('m_4').disabled = false
                                                document.getElementById('m_5').disabled = false
                                                document.getElementById('m_6').disabled = false
                                                document.getElementById('m_2').disabled = false
                                                document.getElementById('m_3').disabled = false
                                        }
                                }

                                var GCSenderShow = function() {
                                        lines = 0
                                        progressBar.innerHTML = ''
                                        leftPanel.style.visibility = 'visible'
                                        centerPanel.style.visibility = 'visible'
                                        rightPanel.style.visibility = 'visible'
                                        var view3d = document.getElementById("3dView")
                                        view3d.style.display = "block"
                                        progressBar.style.width = "0%"

                                        abbBB = false; toggleGCconv()
                                }
                                var GCSenderHide = function() {
                                        $("#configArea").hide()
                                        leftPanel.style.visibility = 'hidden'
                                        centerPanel.style.visibility = 'hidden'
                                        rightPanel.style.visibility = 'hidden'
                                        var view3d = document.getElementById("3dView")
                                        view3d.style.display = "none"
                                        setTimeout(() => {
                                                progressBar.style.width = "0%"
                                                sentGCodeLines = 0; totalGCodeLines = 0
                                        }, 1000); isImageMode = false
                                }

                                var usedFileNames = []
                                function makeUniqueFlName(value) {
                                        var uniqueValue = value, counter = 1
                                        while (usedFileNames.includes(uniqueValue)) {
                                                uniqueValue = value + "_" + counter
                                                counter++
                                        }; return uniqueValue
                                }
                              
                                var isImageMode = false
                                function obj2gc() {
                                        if (mode === 'cutter') {
                                                isImageMode = false; svg2gc(md = 0)
                                        } else if (mode === 'engrave') {
                                                isImageMode = false; svg2gc(md = 1);
                                        } else if (mode === 'image') {
                                                isImageMode = true; img2gc();
                                        } else {
                                                throw new Error("mode must be 'image', 'cutter' or 'engrave'")
                                        }

                                        var content = editor.getValue()
                                        var updatedContent = content.replace(/obj2gc\([^)]*\)/g, "")
                                        editor.setValue(updatedContent, -1); editor.focus()
                                }

                                function prepareGCodeSettings(type) {
                                        var minPWR = parseInt($("#_02").val())
                                        var maxPWR = parseInt($("#_03").val())
                                        var speedTRVL = parseInt($("#_04").val())
                                        var speedLSR = parseInt($("#_05").val())
                                        var passes = parseInt($("#_06").val())
                                        var rowPerMM = parseInt($("#_07").val())
                                        var zeta = parseFloat($("#_08").val())
                                        var zMax = parseFloat($("#_09").val())
                                        var air = parseInt($("#_10").val())
                                        var flName = 'GC'

                                        function isValidInteger(value) {
                                                return Number.isInteger(value) && value >= 0
                                        }
                                        function isValidDecimal(value) {
                                                return typeof value === "number" && value >= 0
                                        }
                                        function isValidAir(value) {
                                                return value === 0 || value === 1
                                        }
                                        function isValidFlName(value) {
                                                return (typeof value === "string" &&
                                                        value.trim() !== "" &&
                                                        /^[a-zA-Z0-9_-]+$/.test(value))
                                        }
                                        function isUniqueFlName(value) {
                                                return !usedFileNames.includes(value)
                                        }

                                        if (!isValidInteger(minPWR)) throw new Error("minPWR must be a positive integer")
                                        if (!isValidInteger(maxPWR)) throw new Error("maxPWR must be a positive integer")
                                        if (!isValidInteger(speedTRVL)) throw new Error("speedTRVL must be a positive integer")
                                        if (!isValidInteger(speedLSR)) throw new Error("speedLSR must be a positive integer")
                                        if (!isValidInteger(passes)) throw new Error("passes must be a positive integer")
                                        if (!isValidInteger(rowPerMM)) throw new Error("rowPerMM must be a positive integer")
                                        if (!isValidAir(air)) throw new Error("air must be 0 or 1")
                                        if (!isValidFlName(flName)) throw new Error("flName must be a non-empty string")

                                        if (!isUniqueFlName(flName)) {
                                                flName = makeUniqueFlName(flName)
                                        }
                                        usedFileNames.push(flName)

                                        var gcode = '', pre = '', post = ''

                                        var now = new Date()
                                        now = ('0' + now.getDate()).slice(-2) + '/' +
                                              ('0' + (now.getMonth() + 1)).slice(-2) + '/' +
                                              now.getFullYear() + ' ' +
                                              ('0' + now.getHours()).slice(-2) + ':' +
                                              ('0' + now.getMinutes()).slice(-2) + ':' +
                                              ('0' + now.getSeconds()).slice(-2)

                                        pre += "; Created using HobbyLaser " + now + "\n\n"

                                        pre += "; mode:" + type + "\n"
                                        pre += "; Laser Speed: " + speedTRVL + " mm/min\n"
                                        pre += "; Travel Speed: " + speedLSR + " mm/min\n"
                                        pre += "; Power: [" + minPWR + ", " + maxPWR + "]\n\n"
                                        pre += "G21; units in mm\n"
                                        pre += "G90; absolute positioning\n"
                                        pre += "G0 X0 Y0 Z0 F" + speedTRVL + "\n"
                                        if (air !== 0) pre += "M8; start airAssist\n"

                                        post += "G0 X0 Y0 Z0 F" + speedTRVL + "\n"
                                        if (air !== 0) post += "M9; stop airAssist\n"
                                        post += "M2; end program\n"

                                        return {minPWR, maxPWR, speedTRVL, speedLSR, passes, rowPerMM, zeta, zMax, air, flName, gcode, pre, post}
                                }

                                var abbBB = false
                                function toggleBB() {
                                        abbBB = !abbBB
                                        document.getElementById("m_7").innerText = abbBB ? "◉" : "●"
                                }
                               
                                function svg2gc(md) {
                                        function boundingBoxPreviewPATH(bounds, settings) {
                                                var {minPWR, speedTRVL, speedLSR, zMax} = settings

                                                var g = ''
                                                var xMin = bounds.minX.toFixed(2)
                                                var yMin = (dHeight + 6 - bounds.minY).toFixed(2)
                                                var xMax = bounds.maxX.toFixed(2)
                                                var yMax = (dHeight + 6 - bounds.maxY).toFixed(2)

                                                g += '\n; start BB\n'
                                                for (var i = 0; i < 2; i++) {
                                                        
                                                        g += `M5 ; laser OFF\n`
                                                        g += `G0 X${xMin} Y${yMin} Z${zMax} F${speedTRVL} S${minPWR}\n`
                                                        g += `M3 ; laser ON\n`
                                                        g += `G1 X${xMax} Y${yMin} F${speedLSR} S${minPWR}\n`
                                                        g += `G1 X${xMax} Y${yMax} F${speedLSR} S${minPWR}\n`
                                                        g += `G1 X${xMin} Y${yMax} F${speedLSR} S${minPWR}\n`
                                                        g += `G1 X${xMin} Y${yMin} F${speedLSR} S${minPWR}\n`
                                                        g += `M5 ; laser OFF\n`
                                                        
                                                }
                                                g += '; end BB\n\n'; return g
                                        } 
                                        
                                        try {
                                                var fill, pause = 100, type = 'vector'
                                                var settings = prepareGCodeSettings(type)
                                                var {minPWR, maxPWR, speedTRVL, speedLSR, passes, rowPerMM, zeta, zMax, air, flName, gcode, pre, post, type} = settings

                                                var Points = svgpath.replace(/,/g, ' ')
                                                var Points_1 = svgPathToPoints(Points)
                                                var pointsArray = Points_1.map(cmd => cmd.command + (cmd.values ? cmd.values.join(' ') : '')).join(' ')
                                                var Points_2 = svgPathToClipperPaths(pointsArray)
                                                var paths = use(Points_2.slice())
                                                var bounds = calculateBoundingBox(paths)

                                                // --- distanza tra due punti ---
                                                function distance(p1, p2) {
                                                        return Math.hypot(p1[0] - p2[0], p1[1] - p2[1])
                                                }

                                                // --- ottimizzazione segmenti (Nearest Neighbor) ---
                                                function optimizeSegments(segments) {
                                                        var remaining = segments.slice()
                                                        var optimized = []
                                                        var current = [0, 0]

                                                        while (remaining.length > 0) {
                                                                var nearestIndex = 0
                                                                var nearestDist = Infinity
                                                                var invert = false

                                                                for (var i = 0; i < remaining.length; i++) {
                                                                        var seg = remaining[i]
                                                                        var distStart = distance(current, seg[0])
                                                                        var distEnd = distance(current, seg[1])

                                                                        if (distStart < nearestDist) {
                                                                                nearestDist = distStart
                                                                                nearestIndex = i
                                                                                invert = false
                                                                        }
                                                                        if (distEnd < nearestDist) {
                                                                                nearestDist = distEnd
                                                                                nearestIndex = i
                                                                                invert = true
                                                                        }
                                                                }

                                                                var chosen = remaining[nearestIndex]
                                                                if (invert) chosen = [chosen[1], chosen[0]]

                                                                optimized.push(chosen)
                                                                current = chosen[1]
                                                                remaining.splice(nearestIndex, 1)
                                                        }
                                                        return optimized
                                                }

                                                if (tabBool == false) {
                                                        function contour() {
                                                                for (var pass = 0; pass < passes; pass++) {
                                                                        var zStep = zeta * pass
                                                                        paths.forEach(originalPath => {
                                                                                var path = originalPath.slice()
                                                                                if (path.length > 0) {
                                                                                        path.forEach((point, index) => {
                                                                                                var x = point.X.toFixed(2)
                                                                                                var y = (dHeight + 6 - point.Y).toFixed(2)
                                                                                                if (index === 0) {
                                                                                                        gcode += `G0 X${x} Y${y} Z${zMax} F${speedTRVL} S${minPWR}\n`
                                                                                                        gcode += `M3; laser ON\n`
                                                                                                        gcode += `G1 X${x} Y${y} Z${zMax} F1 S0\n`
                                                                                                        gcode += `G1 X${x} Y${y} Z${zStep} F${speedLSR} S${maxPWR}\n`
                                                                                                        gcode += `; PAUSE:${pause}ms (handled by worker)\n`
                                                                                                } else {
                                                                                                        gcode += `G1 X${x} Y${y} Z${zStep} F${speedLSR} S${maxPWR}\n`
                                                                                                }
                                                                                        }); gcode += `M5; laser OFF\n`
                                                                                }
                                                                        })
                                                                }
                                                        }
                                                }
                                                if (tabBool == true) {
                                                        function contour() {
                                                                for (var pass = 0; pass < passes; pass++) {
                                                                        var zStep = zeta * pass
                                                                        paths.forEach(originalPath => {
                                                                                var path = originalPath.slice()

                                                                                if (path.length > 1) {
                                                                                        var first = path[0], last = path[path.length - 1]
                                                                                        if (Math.abs(first.X - last.X) < 1e-6 && Math.abs(first.Y - last.Y) < 1e-6) {
                                                                                                path.pop()
                                                                                        }
                                                                                        var x0 = path[0].X.toFixed(2)
                                                                                        var y0 = (dHeight + 6 - path[0].Y).toFixed(2)
                                                                                        gcode += `G0 X${x0} Y${y0} Z${zMax} F${speedTRVL} S${minPWR}\n`
                                                                                        gcode += `; PAUSE:${pause}ms (handled by worker)\n`
                                                                                        gcode += `M3; laser ON\n`

                                                                                        for (var i = 1; i < path.length; i++) {
                                                                                                var x = path[i].X.toFixed(2)
                                                                                                var y = (dHeight + 6 - path[i].Y).toFixed(2)
                                                                                                gcode += `G1 X${x} Y${y} Z${zStep} F${speedLSR} S${maxPWR}\n`
                                                                                        }; gcode += `M5; laser OFF\n`
                                                                                }
                                                                        })
                                                                }
                                                        }; tabBool = false; updateFillButtons()
                                                }

                                                // --- pattern di riempimento ---
                                                function infillLines(rect, angle = 0) {
                                                        var lines = []
                                                        var rad = angle * Math.PI / 180
                                                        var cosA = Math.cos(rad)
                                                        var sinA = Math.sin(rad)

                                                        var cx = (rect[0] + rect[2]) / 2
                                                        var cy = (rect[1] + rect[3]) / 2

                                                        for (var y = rect[1]; y <= rect[3]; y += 1 / rowPerMM) {
                                                                var p1 = [rect[0], y]
                                                                var p2 = [rect[2], y]

                                                                p1 = [p1[0] - cx, p1[1] - cy]
                                                                p2 = [p2[0] - cx, p2[1] - cy]

                                                                p1 = [p1[0]*cosA - p1[1]*sinA, p1[0]*sinA + p1[1]*cosA]
                                                                p2 = [p2[0]*cosA - p2[1]*sinA, p2[0]*sinA + p2[1]*cosA]

                                                                p1 = [p1[0] + cx, p1[1] + cy]
                                                                p2 = [p2[0] + cx, p2[1] + cy]

                                                                lines.push([p1, p2])
                                                        }
                                                        return lines
                                                }

                                                function intersectInfill(infillLines) {
                                                        window.alert = function () {}
                                                        var clipper = new ClipperLib.Clipper()
                                                        var infillPaths = infillLines.map(line => line.map(([x, y]) => ({ X: x * 1000, Y: y * 1000 })))
                                                        var scaledPaths = JSON.parse(JSON.stringify(paths))
                                                        ClipperLib.JS.ScaleUpPaths(scaledPaths, 1000)
                                                        var result = new ClipperLib.Paths()
                                                        clipper.AddPaths(infillPaths, ClipperLib.PolyType.ptSubject, false)
                                                        clipper.AddPaths(scaledPaths, ClipperLib.PolyType.ptClip, true)
                                                        clipper.Execute(ClipperLib.ClipType.ctIntersection, result, ClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero)
                                                        ClipperLib.JS.ScaleDownPaths(result, 1000)
                                                        return result
                                                }

                                                function hexPattern(rect, size) {
                                                        var w = size * 2, h = Math.sqrt(3) * size
                                                        var dx = 3/2 * size, dy = h, lines = []
                                                        var [minX, minY, maxX, maxY] = rect

                                                        for (var y = minY; y <= maxY + h; y += dy) {
                                                                for (var x = minX; x <= maxX + w; x += dx) {
                                                                        var offsetY = (Math.floor((x - minX) / dx) % 2) * (h / 2)
                                                                        var cx = x
                                                                        var cy = y + offsetY

                                                                        var hexPoints = []
                                                                        for (var i = 0; i < 6; i++) {
                                                                                var angle = Math.PI / 3 * i
                                                                                var px = cx + size * Math.cos(angle)
                                                                                var py = cy + size * Math.sin(angle)
                                                                                hexPoints.push([px, py])
                                                                        }
                                                                        for (var i = 0; i < 6; i++) {
                                                                                var p1 = hexPoints[i]
                                                                                var p2 = hexPoints[(i + 1) % 6]
                                                                                lines.push([p1, p2])
                                                                        }
                                                                }
                                                        }
                                                        return lines
                                                }

                                                function gridPattern(rect, spacing) {
                                                        var lines = []
                                                        var [minX, minY, maxX, maxY] = rect

                                                        for (var y = minY; y <= maxY; y += spacing) {
                                                                var p1 = [minX, y]
                                                                var p2 = [maxX, y]
                                                                lines.push([p1, p2])
                                                        }
                                                        for (var x = minX; x <= maxX; x += spacing) {
                                                                var p1 = [x, minY]
                                                                var p2 = [x, maxY]
                                                                lines.push([p1, p2])
                                                        }
                                                        return lines
                                                }

                                                function triPattern(rect, size) {
                                                        var lines = []
                                                        var [minX, minY, maxX, maxY] = rect
                                                        var h = (Math.sqrt(3) / 2) * size

                                                        for (var y = minY; y <= maxY + h; y += h) {
                                                                for (var x = minX; x <= maxX + size; x += size) {
                                                                        var offsetY = ((Math.floor((x - minX) / size)) % 2) * (h / 2)
                                                                        var cx = x, cy = y + offsetY
                                                                        var t1 = [
                                                                                [cx, cy],
                                                                                [cx + size / 2, cy + h],
                                                                                [cx - size / 2, cy + h]
                                                                        ]
                                                                        lines.push([t1[0], t1[1]])
                                                                        lines.push([t1[1], t1[2]])
                                                                        lines.push([t1[2], t1[0]])

                                                                        var t2 = [
                                                                                [cx, cy + h],
                                                                                [cx + size / 2, cy],
                                                                                [cx - size / 2, cy]
                                                                        ]
                                                                        lines.push([t2[0], t2[1]])
                                                                        lines.push([t2[1], t2[2]])
                                                                        lines.push([t2[2], t2[0]])
                                                                }
                                                        }
                                                        return lines
                                                }

                                                // --- scrittura GCODE dai segmenti ottimizzati ---
                                                function engraveSegments(segments) {
                                                        var optimized = optimizeSegments(segments)
                                                        for (var pass = 0; pass < passes; pass++) {
                                                                var zStep = zeta * pass
                                                                optimized.forEach(seg => {
                                                                        var [x1, y1] = seg[0]
                                                                        var [x2, y2] = seg[1]
                                                                        x1 = x1.toFixed(2)
                                                                        y1 = (dHeight + 6 - y1).toFixed(2)
                                                                        x2 = x2.toFixed(2)
                                                                        y2 = (dHeight + 6 - y2).toFixed(2)

                                                                        gcode += `M5; laser OFF\n`
                                                                        gcode += `G0 X${x1} Y${y1} Z${zMax} F${speedTRVL} S${minPWR}\n`
                                                                        gcode += `M3; laser ON\n`
                                                                        gcode += `G1 X${x2} Y${y2} Z${zStep} F${speedLSR} S${maxPWR}\n`
                                                                        gcode += `M5; laser OFF\n`
                                                                })
                                                        }
                                                }

                                                // --- logica principale ---
                                                if (md == 0) {
                                                        contour()
                                                        if (abbBB) {gcode = pre + boundingBoxPreviewPATH(bounds, settings) + gcode + post}
                                                        else {gcode = pre + gcode + post}
                                                } else {
                                                        if (inFill == '') {
                                                                fill = infillLines([bounds.minX, bounds.minY, bounds.maxX, bounds.maxY])
                                                        } else if (inFill == 'hex') {
                                                                fill = hexPattern([bounds.minX, bounds.minY, bounds.maxX, bounds.maxY], 2)
                                                                inFill = ''
                                                        } else if (inFill == 'grid') {
                                                                fill = gridPattern([bounds.minX, bounds.minY, bounds.maxX, bounds.maxY], 3)
                                                                inFill = ''
                                                        } else if (inFill == 'tri') {
                                                                fill = triPattern([bounds.minX, bounds.minY, bounds.maxX, bounds.maxY], 5)
                                                                inFill = ''
                                                        }

                                                        var intersectedPaths = intersectInfill(fill)
                                                        var segments = []
                                                        intersectedPaths.forEach(path => {
                                                                for (var i = 0; i < path.length - 1; i++) {
                                                                        segments.push([[path[i].X, path[i].Y], [path[i+1].X, path[i+1].Y]])
                                                                }
                                                        })

                                                        engraveSegments(segments)
                                                        contour()

                                                        if (abbBB) {gcode = pre + boundingBoxPreviewPATH(bounds, settings) + gcode + post}
                                                        else {gcode = pre + gcode + post}
                                                }

                                                saveGCODE(gcode, flName, "vector")
                                                GCSenderShow()
                                        } catch (error) {
                                                console.error(error.message)
                                        }
                                }

                                function img2gc() {
                                        function boundingBoxPreviewIMG(settings) {
                                                var {minPWR, speedTRVL, speedLSR, zMax} = settings

                                                var g = ''
                                                var xMin = borderX.toFixed(2)
                                                var yMin = (dHeight - (convertToMM(scaledHeight) - borderY)).toFixed(2)
                                                var xMax = (borderX + convertToMM(scaledWidth)).toFixed(2)
                                                var yMax = (dHeight + borderY).toFixed(2)

                                                g += '\n; start BB\n'
                                                for (var i = 0; i < 2; i++) {
                                                        g += `M5 ; laser OFF\n`
                                                        g += `G0 X${xMin} Y${yMin} Z${zMax} F${speedTRVL} S${minPWR}\n`
                                                        g += `M3 ; laser ON\n`
                                                        g += `G1 X${xMax} Y${yMin} F${speedLSR} S${minPWR}\n`
                                                        g += `G1 X${xMax} Y${yMax} F${speedLSR} S${minPWR}\n`
                                                        g += `G1 X${xMin} Y${yMax} F${speedLSR} S${minPWR}\n`
                                                        g += `G1 X${xMin} Y${yMin} F${speedLSR} S${minPWR}\n`
                                                        g += `M5 ; laser OFF\n`
                                                }
                                                g += '; end BB\n\n'; return g
                                        }
                                        
                                        try {
                                                var type = 'raster'
                                                var settings = prepareGCodeSettings(type)
                                                var {minPWR, maxPWR, speedTRVL, speedLSR, passes, rowPerMM, zeta, zMax, air, flName, gcode, pre, post, type} = settings

                                                var imageData = ctxIMG.getImageData(0, 0, scaledWidth, scaledHeight)
                                                var width = imageData.width, height = imageData.height, data = imageData.data

                                                gcode += "; mode: raster\n"

                                                function findActivePixelRange(y) {
                                                        var firstActivePixel = -1
                                                        var lastActivePixel = -1
                                                        for (var ix = 0; ix < width; ix++) {
                                                                var index = (y * width + ix) * 4
                                                                var red = data[index]
                                                                var green = data[index + 1]
                                                                var blue = data[index + 2]
                                                                var alpha = data[index + 3]
                                                                var isWhite = red > 240 && green > 240 && blue > 240
                                                                var isTransparent = alpha <= 10
                                                                if (!isWhite && !isTransparent) {
                                                                        if (firstActivePixel === -1) firstActivePixel = ix
                                                                        lastActivePixel = ix
                                                                }
                                                        }
                                                        return { firstActivePixel, lastActivePixel }
                                                }

                                                function generatePassGcode(zOffset) {
                                                        var powerStep = 5
                                                        var powerTolerance = 5
                                                        var lineSpacing = 1 / rowPerMM
                                                        for (var yMM = 0; yMM < convertToMM(height); yMM += lineSpacing) {
                                                                var y = Math.round(yMM * 96 / 25.4)
                                                                if (y >= height) break
                                                                var { firstActivePixel, lastActivePixel } = findActivePixelRange(y)
                                                                if (firstActivePixel === -1) continue
                                                                var startX = firstActivePixel
                                                                var endX = lastActivePixel
                                                                var step = (y % 2 === 0) ? 1 : -1
                                                                if (step === -1) [startX, endX] = [endX, startX]
                                                                var yCoord = dHeight - (yMM - borderY)
                                                                var rowGcode = ''
                                                                var drawing = false
                                                                var lastPower = 0
                                                                for (var ix = startX; ix !== endX + step; ix += step) {
                                                                        var idx = (y * width + ix) * 4
                                                                        var red = data[idx]
                                                                        var green = data[idx + 1]
                                                                        var blue = data[idx + 2]
                                                                        var alpha = data[idx + 3]
                                                                        var isWhite = red > 240 && green > 240 && blue > 240
                                                                        var isTransparent = alpha <= 10
                                                                        var power = 0
                                                                        if (!isWhite && !isTransparent) {
                                                                                var brightness = red * 0.3 + green * 0.59 + blue * 0.11
                                                                                power = minPWR + (1.0 - brightness / 255.0) * (maxPWR - minPWR)
                                                                                power = Math.round(power / powerStep) * powerStep
                                                                        }
                                                                        if (power > 0) {
                                                                                if (!drawing) {
                                                                                        var segmentStartX = convertToMM(ix) + borderX
                                                                                        rowGcode += `G0 X${segmentStartX.toFixed(3)} Y${yCoord.toFixed(3)} Z${zMax} F${speedTRVL}\n`
                                                                                        drawing = true
                                                                                        lastPower = power
                                                                                } else if (Math.abs(power - lastPower) > powerTolerance) {
                                                                                        var xCoord = convertToMM(ix) + borderX
                                                                                        rowGcode += `G1 X${xCoord.toFixed(3)} Y${yCoord.toFixed(3)} Z${zOffset.toFixed(3)} S${lastPower} F${speedLSR}\n`
                                                                                        rowGcode += `G1 X${xCoord.toFixed(3)} Y${yCoord.toFixed(3)} Z${zOffset.toFixed(3)} S${power} F${speedLSR}\n`
                                                                                        lastPower = power
                                                                                }
                                                                        } else {
                                                                                if (drawing) {
                                                                                        var xCoord = convertToMM(ix - step) + borderX
                                                                                        rowGcode += `G1 X${xCoord.toFixed(3)} Y${yCoord.toFixed(3)} Z${zOffset.toFixed(3)} S${lastPower} F${speedLSR}\n`
                                                                                        drawing = false
                                                                                }
                                                                        }
                                                                }
                                                                if (drawing) {
                                                                        var xCoord = convertToMM(endX) + borderX
                                                                        rowGcode += `G1 X${xCoord.toFixed(3)} Y${yCoord.toFixed(3)} Z${zOffset.toFixed(3)} S${lastPower} F${speedLSR}\n`
                                                                }
                                                                gcode += rowGcode
                                                        }
                                                }

                                                for (var pass = 0; pass < passes; pass++) {
                                                        generatePassGcode(pass * zeta)
                                                }

                                                if (abbBB) {gcode = pre + boundingBoxPreviewIMG(settings) + gcode + post}
                                                else {gcode = pre + gcode + post}

                                                saveGCODE(gcode, flName, "raster")
                                                GCSenderShow()
                                        } catch (error) {
                                                console.error(error.message)
                                        }
                                }
                                function roundCoord(coord){return Math.round(coord * 10) / 10}
                                function convertToMM(value, dpi = 96){var mmPerInch = 25.4; return (value / dpi) * mmPerInch}

                                function getCurrentGRBLValues() {
                                        var acc = Number(document.getElementById('_11').value) || 500

                                        var speedTRVL = Number(document.getElementById('_04').value) || 1000
                                        var speedLSR  = Number(document.getElementById('_05').value) || 600

                                        return {acc, speedTRVL, speedLSR}
                                }
                                function estimateJobTime(gcodeText, speedTRVL, speedLSR, accel, overheadPerCmd = 0.003, corrFactor = 1.15) {
                                        var lines = gcodeText.split(/\r?\n/)
                                        var timeSec = 0
                                        var last = {x: 0, y: 0, z: 0}
                                        var mmPerMinToMmPerSec = 1 / 60

                                        for (var raw of lines) {
                                                var line = raw.split(';')[0].trim()
                                                if (!line) continue
                                                timeSec += overheadPerCmd

                                                if (line.startsWith('G4')) {
                                                        var match = line.match(/P([\d.]+)/)
                                                        if (match) timeSec += parseFloat(match[1]) / 1000; continue
                                                }
                                                if (line.startsWith('M3') || line.startsWith('M4') || line.startsWith('M5')) {
                                                        timeSec += 0.01; continue
                                                }

                                                if (line.startsWith('G0') || line.startsWith('G1')) {
                                                        var args = {}
                                                        line.replace(/([XYZF])([\-\d.]+)/g, (_, k, v) => { args[k] = parseFloat(v) })

                                                        var x = args.X ?? last.x
                                                        var y = args.Y ?? last.y
                                                        var z = args.Z ?? last.z

                                                        var dist = Math.sqrt(
                                                                Math.pow((x - last.x), 2) +
                                                                Math.pow((y - last.y), 2) +
                                                                Math.pow((z - last.z), 2)
                                                        )

                                                        var feed = line.startsWith('G0') ? speedTRVL : speedLSR
                                                        if (args.F) feed = args.F
                                                        var speed = feed * mmPerMinToMmPerSec

                                                        var accelDist = (speed * speed) / (2 * accel)
                                                        var moveTime
                                                        if (dist < 2 * accelDist) {
                                                                moveTime = 2 * Math.sqrt(dist / accel)
                                                        } else {
                                                                var accelTime = speed / accel
                                                                var cruiseDist = dist - 2 * accelDist
                                                                var cruiseTime = cruiseDist / speed
                                                                moveTime = 2 * accelTime + cruiseTime
                                                        }

                                                        if (dist < 1) moveTime *= 2

                                                        var dynOverhead = overheadPerCmd * (1 + (1 / Math.max(dist, 0.05)))
                                                        timeSec += dynOverhead

                                                        if (/S\d+/.test(line)) {
                                                                moveTime *= 1.2
                                                        }

                                                        timeSec += moveTime
                                                        last = {x, y, z}
                                                }
                                        }
                                        return timeSec * corrFactor
                                }

                                var db, request = indexedDB.open("GCODE_DB", 1)
                                indexedDB.deleteDatabase("GCODE_DB")
                                var dirName = document.getElementById("_10").value

                                request.onupgradeneeded = function(event) {
                                        db = event.target.result
                                        var fileStore = db.createObjectStore("gcode_files", {keyPath: "id", autoIncrement: true})
                                        fileStore.createIndex("name", "name", {unique: false})
                                }

                                request.onsuccess = function(event) {
                                        db = event.target.result
                                        loadFiles()
                                }

                                function saveGCODE(data, flName, mode) {
                                        var fileName = flName
                                        var gcode = data
                                        gcodeText = data
                                        if (!fileName || !gcode) return

                                        var blob = new Blob([gcode], {type: "text/plain"})

                                        var transaction = db.transaction("gcode_files", "readwrite")
                                        var store = transaction.objectStore("gcode_files")
                                        store.add({name: fileName, data: blob, mode: mode}) // mode = "vector" | "raster"

                                        transaction.oncomplete = function() {
                                                gcode = ""; loadFiles()
                                        }
                                }

                                var gcodeText = ""
                                function loadFiles() {
                                        var speedTRVL = parseInt($("#_04").val())                     
                                        var speedLSR = parseInt($("#_05").val())
                                        var transaction = db.transaction("gcode_files", "readonly")
                                        var store = transaction.objectStore("gcode_files")
                                        var request = store.getAll()

                                        request.onsuccess = function() {
                                                var fileList = document.getElementById("fileList")
                                                fileList.innerHTML = ""

                                                request.result.forEach(file => {
                                                        var li = document.createElement("li")
                                                        li.textContent = "   ├── " + file.name + " [" + (file.mode || "vector") + "]"
                                                        li.setAttribute("draggable", "true")
                                                        li.addEventListener("dragstart", function(e) {
                                                                e.dataTransfer.setData("text/plain", li.dataset.id)
                                                                li.classList.add("dragging")
                                                                li.classList.add("ghost")   // 👈 aggiunta classe ghost
                                                                draggedElement = li
                                                        })
                                                        li.addEventListener("dragend", function() {
                                                                li.classList.remove("dragging")
                                                                li.classList.remove("ghost") // 👈 rimossa classe ghost
                                                        })
                                                        li.addEventListener("dragover", function(e) {
                                                                e.preventDefault()
                                                                const dragging = document.querySelector(".dragging")
                                                                if (dragging && dragging !== li) {
                                                                        var parent = li.parentNode
                                                                        var rect = li.getBoundingClientRect()
                                                                        var offset = e.clientY - rect.top
                                                                        if (offset > rect.height / 2) {
                                                                                parent.insertBefore(dragging, li.nextSibling)
                                                                        } else {
                                                                                parent.insertBefore(dragging, li)
                                                                        }
                                                                }
                                                        })

                                                        var buttonContainer = document.createElement("div")
                                                        buttonContainer.classList.add("button-container")

                                                        var downloadBtn = document.createElement("button")
                                                        downloadBtn.textContent = "download"
                                                        downloadBtn.classList.add("btTool")
                                                        downloadBtn.onclick = function() {downloadFile(file)}

                                                        var deleteBtn = document.createElement("button")
                                                        deleteBtn.textContent = "delete"
                                                        deleteBtn.classList.add("btTool")
                                                        deleteBtn.onclick = function() {deleteFile(file.id)}

                                                        var dBtn = document.createElement("button")
                                                        dBtn.textContent = "add view"
                                                        dBtn.classList.add("btTool")
                                                        dBtn.onclick = function() { 
                                                                var reader = new FileReader()
                                                                reader.onload = function(e) {
                                                                        gcodeText = e.target.result
                                                                        isImageMode = (file.mode === "raster")
                                                                        gcVIEW(gcodeText)

                                                                        var {acc, speedTRVL, speedLSR} = getCurrentGRBLValues()
                                                                        var estSec = estimateJobTime(gcodeText, speedTRVL, speedLSR, acc)

                                                                        var h = Math.floor(estSec / 3600)
                                                                        var m = Math.floor((estSec % 3600) / 60)
                                                                        var s = Math.floor(estSec % 60)
                                                                        document.getElementById('time').textContent = `estimtedTime: ${h}h ${m}m ${s}s`
                                                                }; reader.readAsText(file.data)
                                                        }

                                                        buttonContainer.appendChild(dBtn)
                                                        buttonContainer.appendChild(downloadBtn)
                                                        buttonContainer.appendChild(deleteBtn)

                                                        li.appendChild(buttonContainer)
                                                        fileList.appendChild(li)
                                                })
                                        }
                                }

                                function downloadFile(file) {
                                        var url = URL.createObjectURL(file.data)
                                        var a = document.createElement("a")
                                        a.href = url
                                        a.download = file.name + ".gcode"
                                        document.body.appendChild(a)
                                        a.click()
                                        document.body.removeChild(a)
                                }

                                function deleteFile(id) {
                                        var transaction = db.transaction("gcode_files", "readwrite")
                                        var store = transaction.objectStore("gcode_files")
                                        store.delete(id)
                                        transaction.oncomplete = function() { loadFiles() }
                                }                               
                        </script>
                </div>
                
                <div id="GCSender" style="">                
                        <div id="leftPanel" style="background:#101010; position:absolute; width:200px; top:100px; z-index:500;
                        left:calc(50% - (var(--viewWidth) / 2) - 100px); border:1px solid #3c3c3c; z-index:500; visibility:hidden">

                                <button id="connect" class="btAlert" style="position:absolute; left:10px; top:10px">connect</button>
                                <button id="stop" class="btAlert" style="position:absolute; left:10px; top:45px">Stop</button>                
                                <button id="send" class="btAlert" style="position:absolute; left:10px; top:80px">Send ...</button>
                                <button id="pause" class="btAlert" style="position:absolute; left:10px; top:115px">Pause</button>
                                <button id="resume" class="btAlert" style="position:absolute; left:10px; top:150px">Resume</button>

                                <button id="config"class="btAlert" style="position:absolute;  margin-left:10px; bottom:10px">setGRBL</button>

                                <input class="txtInp" type="text" id="cmd" style="text-align:center;
                                position:absolute; left:10px; top:200px; width:177px" placeholder="send command 'ctrl + enter'"/>

                                <div id="grbl" style="position:absolute; bottom:100px; left:10px; right:5px;
                                color:gray; font-size:12px; line-height:1.4; white-space:pre-wrap;"></div>                                    
       
                        </div>             

                        <div id="centerPanel" class="panel" style="position:absolute; top:100px; left:0; overflow:hidden; visibility:hidden">
                                <div id="spinner" style="position:absolute; top:50%; left:50%; transform:translate(-50%, -50%); font-size:20px"></div>
                                <div id="3dView">
                                        <script>
                                                //------ gcode VIEW
                                                function clrScene(scene) {
                                                        while (scene.children.length > 0) {
                                                                var obj = scene.children[0];
                                                                if (obj.geometry) obj.geometry.dispose();
                                                                if (obj.material) obj.material.dispose();
                                                                scene.remove(obj);
                                                        }
                                                }

                                                function GCodeParser(handlers) {
                                                        this.handlers = handlers || {}
                                                }
                                                GCodeParser.prototype.parseLine = function (text) {
                                                        var comment = null
                                                        var semicolonIndex = text.indexOf(';')
                                                        if (semicolonIndex >= 0) {
                                                                comment = text.substring(semicolonIndex).trim()
                                                                text = text.substring(0, semicolonIndex).trim() // rimuovi commento dal comando
                                                        }

                                                        if (comment && this.handlers['comment']) {
                                                                this.handlers['comment'](comment)
                                                        }

                                                        if (text) {
                                                                var tokens = text.split(' ')
                                                                var cmd = tokens[0]
                                                                var args = { cmd: cmd }
                                                                tokens.slice(1).forEach(function (token) {
                                                                        if (token.length < 2) return
                                                                        var key = token[0].toLowerCase()
                                                                        var value = parseFloat(token.substring(1))
                                                                        if (!isNaN(value)) {
                                                                                args[key] = value
                                                                        }
                                                                })
                                                                var handler = this.handlers[cmd] || this.handlers['default']
                                                                if (handler) {
                                                                        handler(args)
                                                                }
                                                        }
                                                }
                                                GCodeParser.prototype.parse = function (gcode) {
                                                        var lines = gcode.split('\n')
                                                        for (var i = 0; i < lines.length; i++) {
                                                                this.parseLine(lines[i])
                                                        }
                                                }

                                                var visitedSegments = [], lastPower = 0
                                                function createObjFromGC(gcode) {
                                                        var positions = [], colors = [], pathPoints = [], lastLine = { x: 0, y: 0, z: 0 }
                                                        var visitedSegments = [], lastPower = 0
                                                        var inBB = false // flag bounding box
                                                        var bbColor = new THREE.Color(0xff0000) // rosso fisso per BB
                                                        var isImageMode = gcode.includes('; mode:raster')

                                                        function addSegment(p1, p2, power, isBB) {
                                                                positions.push(p1.x, p1.y, p1.z)
                                                                positions.push(p2.x, p2.y, p2.z)

                                                                var color
                                                                if (isBB) {
                                                                        // BB sempre rosso, indipendentemente dal tipo di G-code
                                                                        color = bbColor
                                                                } else {
                                                                        // resto dei segmenti
                                                                        var intensity = power / 255
                                                                        if (isImageMode) intensity = 1 - intensity
                                                                        color = new THREE.Color().setRGB(intensity, intensity, intensity)
                                                                }

                                                                colors.push(color.r, color.g, color.b)
                                                                colors.push(color.r, color.g, color.b)

                                                                pathPoints.push({ ...p2 })
                                                                visitedSegments.push(false)
                                                        }

                                                        function moveTo(args) {
                                                                if ('s' in args) lastPower = args.s

                                                                var zOffset = isImageMode ? -lastPower / 255 : 0
                                                                var zReal = args.z ?? lastLine.z

                                                                var newLine = {
                                                                        x: args.x ?? lastLine.x,
                                                                        y: args.y ?? lastLine.y,
                                                                        z: zReal + zOffset
                                                                }

                                                                addSegment(lastLine, newLine, lastPower, inBB)
                                                                lastLine = { ...newLine }
                                                        }

                                                        function moveWithoutDrawing(args) {
                                                                if ('s' in args) lastPower = args.s
                                                                var zReal = args.z ?? lastLine.z
                                                                lastLine = {
                                                                        x: args.x ?? lastLine.x,
                                                                        y: args.y ?? lastLine.y,
                                                                        z: zReal
                                                                }
                                                        }

                                                        var parser = new GCodeParser({
                                                                comment: c => {
                                                                        if (c.includes('start BB')) inBB = true
                                                                        if (c.includes('end BB')) inBB = false
                                                                },
                                                                G0: args => moveWithoutDrawing(args),
                                                                G1: args => moveTo(args)
                                                        })

                                                        parser.parse(gcode)

                                                        if (positions.length === 0) return null

                                                        var geometry = new THREE.BufferGeometry()
                                                        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3))
                                                        geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3))
                                                        geometry.computeBoundingBox()

                                                        var center = geometry.boundingBox.getCenter(new THREE.Vector3())
                                                        var size = geometry.boundingBox.getSize(new THREE.Vector3()).length()

                                                        var posAttr = geometry.getAttribute('position')
                                                        for (var i = 0; i < posAttr.count; i++) {
                                                                posAttr.setXYZ(
                                                                        i,
                                                                        posAttr.getX(i) - center.x,
                                                                        posAttr.getY(i) - center.y,
                                                                        posAttr.getZ(i) - center.z
                                                                )
                                                        }
                                                        posAttr.needsUpdate = true

                                                        pathPoints = pathPoints.map(p => ({
                                                                x: p.x - center.x,
                                                                y: p.y - center.y,
                                                                z: p.z - center.z
                                                        }))

                                                        var material = new THREE.LineBasicMaterial({ vertexColors: true })
                                                        var line = new THREE.LineSegments(geometry, material)

                                                        return { line, pathPoints, center, size }
                                                }

                                                var view = document.getElementById("3dView")
                                                var tW = window.innerHeight * 0.6
                                                var tH = window.innerHeight * 0.6

                                                var renderer = new THREE.WebGLRenderer({antialias: true})
                                                renderer.setSize(tW, tH)
                                                renderer.setPixelRatio(window.devicePixelRatio)
                                                renderer.setClearColor(0x101010, 1)
                                                view.appendChild(renderer.domElement)

                                                var scene = new THREE.Scene()
                                                var camera = new THREE.PerspectiveCamera(40, tW / tH, 1, 1000)
                                                camera.lookAt(0,0,0); camera.up.set(0, 1, 0)
                                                var controls = new THREE.OrbitControls(camera, renderer.domElement)

                                                function resetCAMERA() {
                                                        camera = new THREE.PerspectiveCamera(40, tW / tH, 0.1, 1000)
                                                        camera.position.set(5, -22, 138)
                                                        controls = new THREE.OrbitControls(camera, renderer.domElement)
                                                        controls.update()
                                                }

                                                function loop() {
                                                        requestAnimationFrame(loop)
                                                        controls.update()
                                                        renderer.render(scene, camera)
                                                }; loop()

                                                function renderGCode(object) {
                                                        clrScene(scene); scene.add(object)
                                                        if (typeof line !== 'undefined' && line !== null) {
                                                                scene.add(line)
                                                        }
                                                        camera.position.set(5, -22, 138)
                                                        camera.lookAt(center)
                                                }

                                                var pathPoints = [], isPaused = false, step = 0, object
                                                var gcVIEW = function (gcode) {
                                                        var result = createObjFromGC(gcode); if (!result) return
                                                        object = result.line; pathPoints = result.pathPoints
                                                        center = result.center; size = result.size

                                                        renderGCode(object)
                                                        view.style.visibility = 'visible'
                                                }

                                                window.addEventListener('resize', function () {
                                                        tW = view.offsetWidth
                                                        tH = view.offsetHeight
                                                        renderer.setSize(tW, tH)
                                                        camera.aspect = tW / tH
                                                        camera.updateProjectionMatrix()
                                                })

                                                var spinner = document.getElementById('spinner');
                                                var frames = ['⠁','⠂','⠄','⡀','⢀','⠠','⠐','⠈'].reverse()
                                                var i = 0; intervalId = null;

                                                var spinnerEl = document.getElementById('spinner')
                                                var spinnerFrames = ['⠁','⠂','⠄','⡀','⢀','⠠','⠐','⠈'].reverse()
                                                var spinnerInterval = null
                                                function startSpinner() {
                                                        if (spinnerInterval) return
                                                        var i = 0; spinnerInterval = setInterval(() => {
                                                                spinnerEl.textContent = spinnerFrames[i]
                                                                i = (i + 1) % spinnerFrames.length
                                                        }, 100); spinnerEl.style.visibility = 'visible'
                                                }

                                                function stopSpinner() {
                                                    clearInterval(spinnerInterval)
                                                    spinnerInterval = null
                                                    spinnerEl.style.visibility = 'hidden'
                                                }
                                        </script>
                                </div>    
                        </div>

                        <div id="configArea" class="panel" style="position:absolute; top:100px; left:0; overflow:auto; display:none">                
                                <table id="configTable">
                                        <thead>
                                                <tr>
                                                        <th style="text-align:left"></th>
                                                        <th style="text-align:right"></th>
                                                        <th style="text-align:right"></th>
                                                </tr>
                                        </thead>
                                        <tbody>
                                                <!-- Le righe saranno aggiunte dinamicamente qui -->
                                        </tbody>
                                </table>

                                <script>
                                        var accX = '', accY = '', accZ = ''
                                
                                        var configVisible = false
                                        document.getElementById('config').addEventListener('click', function () {
                                                if (isConnected == true) {
                                                        configVisible = !configVisible
                                                        if (configVisible) {
                                                                loadConfigData()
                                                                $("#configArea").show()
                                                                $("#pre, #post, label[for='pre'], label[for='post']").show()
                                                        } else {
                                                                $("#configArea").hide()
                                                                $("#pre, #post, label[for='pre'], label[for='post']").hide()
                                                                sendConfigToGRBL()
                                                        }
                                                } else {
                                                        console.error("ConnectController");
                                                }
                                        });

                                        function loadConfigData() {
                                                accX = document.getElementById('_11').value
                                                accY = document.getElementById('_11').value
                                                accZ = document.getElementById('_11').value
                                                
                                                $('#configTable tbody').empty()

                                                var configData = [
                                                        { setting: "$0", value: "10", description: "Step pulse time, microseconds" },
                                                        { setting: "$1", value: "25", description: "Step idle delay, milliseconds" },
                                                        { setting: "$2", value: "0", description: "Step pulse invert, mask" },
                                                        { setting: "$3", value: "0", description: "Step direction invert, mask" },
                                                        { setting: "$4", value: "0", description: "Invert step enable pin, boolean" },
                                                        { setting: "$5", value: "0", description: "Invert limit pins, boolean" },
                                                        { setting: "$6", value: "0", description: "Invert probe pin, boolean" },
                                                        { setting: "$10", value: "255", description: "Status report options, mask" },
                                                        { setting: "$11", value: "0.010", description: "Junction deviation, millimeters" },
                                                        { setting: "$12", value: "0.002", description: "Arc tolerance, millimeters" },
                                                        { setting: "$13", value: "0", description: "Report in inches, boolean" },
                                                        { setting: "$20", value: "0", description: "Soft limits enable, boolean" },
                                                        { setting: "$21", value: "0", description: "Hard limits enable, boolean" },
                                                        { setting: "$22", value: "1", description: "Homing cycle enable, boolean" },
                                                        { setting: "$23", value: "0", description: "Homing direction invert, mask" },
                                                        { setting: "$24", value: "25.000", description: "Homing locate feed rate, mm/min" },
                                                        { setting: "$25", value: "500.000", description: "Homing search seek rate, mm/min" },
                                                        { setting: "$26", value: "250", description: "Homing switch debounce delay, milliseconds" },
                                                        { setting: "$27", value: "1.000", description: "Homing switch pull-off distance, millimeters" },
                                                        { setting: "$30", value: "1000", description: "Maximum spindle speed, RPM" },
                                                        { setting: "$31", value: "0", description: "Minimum spindle speed, RPM" },
                                                        { setting: "$32", value: "1", description: "Laser-mode enable, boolean" },
                                                        { setting: "$100", value: "250.000", description: "X-axis steps per millimeter" },
                                                        { setting: "$101", value: "250.000", description: "Y-axis steps per millimeter" },
                                                        { setting: "$102", value: "250.000", description: "Z-axis steps per millimeter" },
                                                        { setting: "$110", value: "500.000", description: "X-axis maximum rate, mm/min" },
                                                        { setting: "$111", value: "500.000", description: "Y-axis maximum rate, mm/min" },
                                                        { setting: "$112", value: "500.000", description: "Z-axis maximum rate, mm/min" },
                                                        { setting: "$120", value: accX, description: "X-axis acceleration, mm/sec^2" },
                                                        { setting: "$121", value: accY, description: "Y-axis acceleration, mm/sec^2" },
                                                        { setting: "$122", value: accZ, description: "Z-axis acceleration, mm/sec^2" },
                                                        { setting: "$130", value: dWidth, description: "X-axis maximum travel, millimeters" },
                                                        { setting: "$131", value: dHeight, description: "Y-axis maximum travel, millimeters" },
                                                        { setting: "$132", value: "200.000", description: "Z-axis maximum travel, millimeters" }
                                                ];

                                                configData.forEach(data => {
                                                        var row = `<tr>
                                                                        <td>${'&nbsp;&nbsp;' + data.setting}</td>
                                                                        <td><input class="txtInp configValue" type="text" value="${data.value}"></td>
                                                                        <td style="padding-left:50px">${data.description}</td>
                                                                </tr>`;
                                                        $('#configTable tbody').append(row);
                                                });
                                        }

                                        function getConfigData() {
                                                var configData = []
                                                $('#configTable tbody tr').each(function () {
                                                        var key = $(this).find('td').eq(0).text().trim()
                                                        var value = $(this).find('input').val()
                                                        var description = $(this).find('td').eq(2).text()

                                                        if (key && value) {
                                                                configData.push({setting: key, value: value, description: description})
                                                        }
                                                }); return configData
                                        }

                                        var isSendingConfig = false
                                        async function sendConfigToGRBL() {
                                                if (isSendingConfig) return
                                                if (!writer) {
                                                        console.error("ConnectController"); return
                                                }

                                                isSendingConfig = true
                                                var config = getConfigData()
                                                for (var item of config) {
                                                        if (!item.setting || item.value === undefined) {
                                                                console.warn("invalid config item:", item); continue
                                                        }

                                                        var line = `${item.setting}=${item.value}`
                                                        try {
                                                                await new Promise(async (resolve, reject) => {
                                                                        var timeout = setTimeout(() => {
                                                                                reject("Timeout waiting for OK from GRBL")
                                                                        }, OK_TIMEOUT)
                                                                        enqueueOkResolver(() => {
                                                                                clearTimeout(timeout); resolve()
                                                                        })
                                                                        await writer.write(encoder.encode(line + "\n"))
                                                                })
                                                        } catch (err) {
                                                                console.error("Error sending config:", err)
                                                        }
                                                }; isSendingConfig = false
                                        }
                                </script>

                        </div>

                        <div id="rightPanel" style="background:#101010; position:absolute; width:500px; top:100px; z-index:500;
                        border:1px solid #3c3c3c; visibility:hidden">

                                <button id="close" class="close-btn" onclick="GCSenderHide()">x</button>

                                <div id="time" style="position:absolute; bottom:5px; left:10px; right:5px;
                                color:gray; font-size:12px; line-height:1.4; white-space:pre-wrap;">estimtedTime:</div>

                                <div style="position:absolute; top:60px; left:20px; font-size:12px">[CACHE STORAGE]</div>

                                <div id="crud-wrapper" style="">              
                                        <div id="crud"> <ul id="fileList"></ul></div>
                                </div>                                
                        </div>

                         <script>
                                var centerPanel = document.getElementById('centerPanel')
                                var centPHeight = centerPanel.offsetHeight

                                window.addEventListener('DOMContentLoaded', function () {
                                        var leftPanel = document.getElementById("leftPanel")
                                        var rightPanel = document.getElementById("rightPanel")
                                        var confArea = document.getElementById('configArea')

                                        leftPanel.style.height = centPHeight + "px"
                                        rightPanel.style.height = centPHeight + "px"

                                        var leftWidth = 200
                                        var centerWidth = centPHeight
                                        var rightWidth = 500  //230

                                        var totalWidth = leftWidth + centerWidth + rightWidth
                                        var startX = (window.innerWidth - totalWidth) / 2

                                        leftPanel.style.left = startX + "px"
                                        centerPanel.style.left = (startX + leftWidth +20) + "px"
                                        confArea.style.left = (startX + leftWidth +20) + "px"
                                        rightPanel.style.left = (startX + leftWidth + centerWidth+40) + "px"
                                })             

                                var sidePanel = document.getElementById("leftPanel")
                                sidePanel.style.height = tH + 5 + "px"

                                var centerX = window.innerWidth / 2
                                var viewLeft = centerX - (tW / 2)
                                sidePanel.style.left = (viewLeft - 120) + "px"
                                
                                  
                                // ------ GCSender
/* =========================
        VARIABILI GLOBALI
========================= */
var progressBar = document.getElementById('progress-bar')
var port, writer, reader, readableStreamClosed
var isSending = false, stopRequested = false, isPaused = false, reconnecting = false
var encoder = new TextEncoder(), reconnectDelay = 500
var isConnected = false, isManualDisconnect = false
var okQueue = [], statusListeners = []
var lineNumber = 0, lastStatusReq = 0
var totalGCodeLines = 0, sentGCodeLines = 0
var parser, lastLine, lastPower, center = {x: 0, y: 0, z: 0}
var pingInterval, OK_TIMEOUT = 1000

/* =========================
        UTILITIES
========================= */
function enqueueOkResolver(resolve) {
        okQueue.push(resolve)
}

function clearOkQueue() {
        while (okQueue.length) {
                try { okQueue.shift()(new Error('streaming aborted')) } catch(e){}
        }
}

function formatGcodeLine(rawLine){
        return rawLine.trim() + '\n'
}

/* =========================
        PARSER 3D
========================= */
function makeStreamParser(scene){
        return new GCodeParser({
                G0: args => {
                        if ('s' in args) lastPower = args.s
                        var zReal = ('z' in args) ? args.z : lastLine.z
                        lastLine = { x: args.x ?? lastLine.x, y: args.y ?? lastLine.y, z: zReal }
                },
                G1: args => {
                        if ('s' in args) lastPower = args.s
                        var powerRatio = isImageMode ? 1 - (lastPower / 255) : (lastPower / 255)
                        var zReal = ('z' in args) ? args.z : lastLine.z
                        var zOffset = -powerRatio
                        var newPt = { x: (args.x ?? lastLine.x) - center.x, y: (args.y ?? lastLine.y) - center.y, z: (zReal + zOffset) - center.z }
                        var oldPt = { x: lastLine.x - center.x, y: lastLine.y - center.y, z: lastLine.z + zOffset - center.z }
                        var geom = new THREE.BufferGeometry()
                        geom.setAttribute('position', new THREE.Float32BufferAttribute([
                                oldPt.x, oldPt.y, oldPt.z, newPt.x, newPt.y, newPt.z
                        ], 3))
                        var c = new THREE.Color().setRGB(powerRatio, powerRatio, powerRatio)
                        geom.setAttribute('color', new THREE.Float32BufferAttribute([
                                c.r, c.g, c.b, c.r, c.g, c.b
                        ], 3))
                        var mat = new THREE.LineBasicMaterial({vertexColors: true})
                        var lineSeg = new THREE.LineSegments(geom, mat)
                        scene.add(lineSeg)

                        stopSpinner()                       
                        lastLine = {x: args.x ?? lastLine.x, y: args.y ?? lastLine.y, z: zReal}
                }
        })
}

/* =========================
        WEB WORKER
========================= */
var workerCode = `
        var lines = [], currentIndex = 0, paused = false, stopped = false

        self.onmessage = (e) => {
                var { cmd, data } = e.data
                if (cmd === 'start') {
                        lines = data.lines
                                .map(l => l.replace(/\\(.*?\\)/g, ''))
                                .map(l => l.split(';')[0].trim())
                                .filter(l => l.length > 0 || /^; PAUSE:/i.test(l))
                        currentIndex = 0; paused = false
                        stopped = false; pump()
                }
                else if (cmd === 'ok') {pump()}
                else if (cmd === 'pause') {paused = true}
                else if (cmd === 'resume') {paused = false; pump()}
                else if (cmd === 'stop') {stopped = true}
        }

        function pump() {
                if (stopped) {
                        self.postMessage({type: 'stopped'}); return
                }
                if (paused) return
                if (currentIndex >= lines.length) {
                        self.postMessage({type: 'done'}); return
                }
                var raw = lines[currentIndex++]
                if (/^; PAUSE:/i.test(raw)) {
                        var ms = parseInt(raw.split(':')[1])
                        self.postMessage({type: 'pause', time: ms})
                } else {
                        self.postMessage({type: 'send', line: {raw, formatted: raw + '\\n'}})
                }
        }
`
var blob = new Blob([workerCode], {type: 'application/javascript'})
var worker = new Worker(URL.createObjectURL(blob))
worker.onerror = e => console.error("Worker error:", e.message)

/* =========================
        STREAMING G-CODE
========================= */
async function streamGCodeWorkerMain(){
        if (!gcodeText || !gcodeText.trim()) return console.warn("G-code empty")
        if (isSending) return console.warn("Streaming in progress")
        if (!isConnected || !writer) {
                try {
                        await connectSerial()
                        await new Promise(r => setTimeout(r, 100))
                } catch(e) {
                        return console.error("Cannot connect:", e)
                }
        }
        stopPingGRBL()
        clrScene && clrScene(scene)
        var pre = createObjFromGC && createObjFromGC(gcodeText)
        if (pre) center = pre.center
        lastLine = {x:0, y:0, z:0}
        lastPower = 0
        parser = makeStreamParser(scene)
        var lines = gcodeText.split('\n')
        totalGCodeLines = lines.filter(l => l.trim() && !l.startsWith(';')).length
        sentGCodeLines = 0
        lineNumber = 0
        isSending = true
        stopRequested = false
        startSpinner(); worker.postMessage({cmd:'start', data:{lines}})
}

/* =========================
        WORKER HANDLER
========================= */
worker.onmessage = async (e) => {
        var msg = e.data
        if (msg.type === 'send') {
                var { raw, formatted } = msg.line
                console.log("→ Sending:", formatted.trim())
                try {
                        await writer.write(encoder.encode(formatted))
                } catch (e) {
                        console.error("Error writing to GRBL:", e); return
                }
                startPingGRBL()
                await new Promise((resolve, reject) => {
                        enqueueOkResolver(async () => {
                                try {
                                        try {parser.parseLine(raw)}
                                        catch (err) {console.warn("parse error:", err)}
                                        sentGCodeLines++; updateProgressBar(); resolve()
                                } catch(e) { reject(e) }
                        })
                })

                worker.postMessage({cmd: 'ok'})
        } else if (msg.type === 'pause') {
                var ms = msg.time || 0
                await new Promise(r => setTimeout(r, ms))
                worker.postMessage({ cmd: 'ok' })
        } else if (msg.type === 'done') {
                isSending = false; stopPingGRBL()
                console.log("Streaming completed")
                
        } else if (msg.type === 'stopped') {
                isSending = false; clearOkQueue()
                console.log("Streaming stopped")
        }
}

/* =========================
        CONTROLLO STREAMING
========================= */
function pauseStreaming(){
        if (!isSending || isPaused) return
        isPaused = true
        writer && writer.write(encoder.encode("!\n")).catch(()=>{})
        worker.postMessage({cmd:'pause'})
}

function resumeStreaming(){
        if (!isPaused) return
        isPaused = false
        writer && writer.write(encoder.encode("~\n")).catch(()=>{})
        worker.postMessage({cmd:'resume'})
}

function stopStreaming(){
        if (!isSending) return
        stopRequested = true
        worker.postMessage({cmd:'stop'})
        clearOkQueue()
}

async function softReset() {
        try {
                await writer.write(new Uint8Array([0x18]))
                await new Promise(r => setTimeout(r, 500))
        } catch (e) {
                console.error("Error:", e)
        }
}

/* =========================
        PROGRESS BAR
========================= */
function updateProgressBar(){
        var bar = document.getElementById('progress-bar')
        if (!bar || totalGCodeLines === 0) return
        bar.style.width = Math.round((sentGCodeLines / totalGCodeLines) * 100) + '%'
}

/* =========================
        SERIAL CONNECTION
========================= */
async function connectSerial(){
        if (isConnected) return
        try {
                if (!port) {
                        var ports = await navigator.serial.getPorts()
                        port = ports[0] || await navigator.serial.requestPort()
                }
                await port.open({baudRate: 115200})
                writer = port.writable.getWriter()
                isConnected = true
                isManualDisconnect = false
                console.log("Connected")
                readSerialData()
                setTimeout(async () => {
                        try {
                                setTimeout(async () => {
                                        await writer.write(new Uint8Array([0x18]))
                                        await writer.write(encoder.encode("$X\n"))
                                }, 1500)
                        } catch(e) { console.error("Error sending $X:", e) }
                }, 500)
        } catch(e) {
                console.error("Connect fail:", e)
        }
}

async function disconnectSerial(){
        isManualDisconnect = true
        stopPingGRBL()
        clearOkQueue()
        try {
                if (reader) {
                        await reader.cancel()
                        if (readableStreamClosed) await readableStreamClosed.catch(()=>{})
                        reader.releaseLock()
                }
                if (writer) {
                        await writer.close()
                        writer.releaseLock()
                }
                if (port) await port.close()
                isConnected = false
                reader = writer = port = readableStreamClosed = null
        } catch(e) { console.error("Disconnect error:", e) }
}

/* =========================
        READ SERIAL DATA
========================= */
async function readSerialData(){
        if (!port) throw new Error("No port")
        var decoder = new TextDecoderStream()
        readableStreamClosed = port.readable.pipeTo(decoder.writable)
        reader = decoder.readable.getReader()
        var buffer = ''
        try {
                while (true) {
                        var {value, done} = await reader.read()
                        if (done) break
                        buffer += value
                        var lines = buffer.split(/\r?\n/)
                        buffer = lines.pop()
                        for (var raw of lines) {
                                var line = raw.trim()
                                if (!line) continue
                                if (line === 'ok') {
                                        var resolver = okQueue.shift()
                                        if (resolver) {
                                                try {
                                                        resolver()
                                                        console.response("← GRBL:", line)
                                                } catch(e){}
                                        }; continue
                                }
                                if (line.startsWith('echo:')) console.warn('[GRBL echo]', line)
                                else if (line.startsWith('[MSG:')) console.info('[GRBL MSG]', line)
                                else if (line.startsWith('error:')) console.error('[GRBL error]', line)
                                else if (line.startsWith('alarm:')) console.error('[GRBL alarm]', line)
                                else if (line.startsWith('<') && line.endsWith('>')) {
                                        statusListeners.forEach(cb => {try{cb(line)} catch(e){}})
                                        var el = document.getElementById('grbl')
                                        if (!el) return
                                        var parts = line.replace(/[<>]/g, '').split('|')
                                        var formatted = parts.map(part => {
                                                if (part.includes(':')) {
                                                        var [key, value] = part.split(':')
                                                        return `${key.trim()}: ${value.trim()}`
                                                }
                                                return part.trim()
                                        }).join('\n')
                                        el.textContent = formatted
                                }
                        }
                }
        } catch(e) {
                console.error('Serial read error:', e)
                isConnected = false
                try {await port.close()} catch(err){}
        } finally {
                try {reader.releaseLock()} catch(e){}
                if (isManualDisconnect) try {await port.close()} catch(e){}
        }
}

/* =========================
        GRBL PING
========================= */
function startPingGRBL(){
        stopPingGRBL()
        pingInterval = setInterval(() => {
                if (isConnected && writer) {
                        writer.write(encoder.encode("$?\n")).catch(()=>{})
                }
        }, 500)
}

function stopPingGRBL(){
        if (pingInterval) clearInterval(pingInterval)
}

/* =========================
UI BINDINGS
========================= */
document.getElementById('connect').addEventListener('click', connectSerial)
document.getElementById('stop').addEventListener('click', disconnectSerial)
document.getElementById('send').addEventListener('click', streamGCodeWorkerMain)
document.getElementById('pause').addEventListener('click', pauseStreaming)
document.getElementById('resume').addEventListener('click', resumeStreaming)




                                async function sendSingleCommand() {
                                        var cmd = document.getElementById('cmd').value.trim()
                                        if (cmd !== "") {
                                                await sendToGRBL(cmd);
                                                console.log(`Command sent: ${cmd}`)
                                                document.getElementById('cmd').value = ""
                                        }
                                }
                                document.getElementById('cmd').addEventListener('keydown', function (e) {
                                        if (e.ctrlKey && e.key === "Enter") {sendSingleCommand()}
                                })

                                //------ jog
                                async function sendJog({ x = 0, y = 0, z = 0, f = 1000 }) {
                                        var dx = Math.abs(x)
                                        var dy = Math.abs(y)
                                        var dz = Math.abs(z)
                                        var distance = Math.max(dx, dy, dz)
                                        var durationMs = (distance / (f / 60)) * 1000

                                        var jogLine = `$J=G91 G21 X${x} Y${y} Z${z} F${f}\n`
                                        await writer.write(encoder.encode(jogLine))
                                        console.log(`[JOG] ${jogLine.trim()}`)

                                        await new Promise(r => setTimeout(r, durationMs + 100))

                                        await writer.write(encoder.encode("G90\n"))
                                        await writer.write(encoder.encode("?\n"))
                                }
                                document.addEventListener("keydown", async function (e) {
                                        if (!e.ctrlKey || !isConnected || isSending || isPaused) return
                                        e.preventDefault()

                                        var step = e.shiftKey ? 10 : 1
                                        var feed = 1000

                                        if (e.key === "ArrowUp")        await sendJog({y: step, f: feed })
                                        if (e.key === "ArrowDown")      await sendJog({y: -step, f: feed})
                                        if (e.key === "ArrowLeft")      await sendJog({x: -step, f: feed})
                                        if (e.key === "ArrowRight")     await sendJog({x: step, f: feed })
                                        if (e.key === "PageUp")         await sendJog({z: step, f: 500  })
                                        if (e.key === "PageDown")       await sendJog({z: -step, f: 500 })
                                })
                                document.addEventListener("keydown", async function (e) {
                                        if (!isConnected || !e.shiftKey) return

                                        var overrideChar = null

                                        switch (e.key.toLowerCase()) {
                                                case "f": overrideChar = "+"; break // feed +
                                                case "g": overrideChar = "-"; break // feed -
                                                case "r": overrideChar = "="; break // feed reset

                                                case "s": overrideChar = "^"; break // spindle +
                                                case "d": overrideChar = "v"; break // spindle -
                                                case "x": overrideChar = "~"; break // spindle reset

                                                case "z": overrideChar = ">"; break // rapid +
                                                case "a": overrideChar = "<"; break // rapid -
                                                case "q": overrideChar = "|"; break // rapid reset
                                        }

                                        if (overrideChar) {
                                                await writer.write(encoder.encode(overrideChar))
                                                console.log(`[OVERRIDE] ${overrideChar}`)
                                                e.preventDefault()
                                        }
                                })

                                async function sendToGRBL(command) {
                                        return new Promise(async (resolve, reject) => {
                                                if (!writer) {
                                                        reject('Serial port writer not available'); return
                                                }
                                                var timeoutId = setTimeout(() => {
                                                        reject('Timeout: No OK response from device')
                                                }, OK_TIMEOUT)
                                                enqueueOkResolver(() => {
                                                        clearTimeout(timeoutId); resolve()
                                                })
                                                try {
                                                        var data = new TextEncoder().encode(command + '\n')
                                                        await writer.write(data)
                                                } catch (e) {
                                                        clearTimeout(timeoutId); reject(e)
                                                }
                                        })
                                }
                        </script>                                 
                </div>

                <script>                                
                        document.addEventListener('keydown', function(event) {
                                if (event.ctrlKey && event.key === 'Delete') {
                                        clearCNVS()
                                        if (imgInstance) {canvas.remove(imgInstance)}
                                        cancBool = true; objNumber = 0
                                }
                                else if (event.ctrlKey && event.key === 'i') {
                                        event.preventDefault()
                                        document.getElementById('input').click()
                                }
                                else if (event.ctrlKey && event.key === '+') {
                                        event.preventDefault()
                                        updateZoom(zoomLevel - zoomFactor)
                                }
                                else if (event.ctrlKey && event.key === '-') {
                                        event.preventDefault()
                                        updateZoom(zoomLevel + zoomFactor)
                                }
                                else if (event.ctrlKey && event.key === 'r') {
                                        event.preventDefault()
                                        resetZoom()
                                }
                                else if (event.ctrlKey && event.key === 'm') {
                                        event.preventDefault()
                                        resetCAMERA()
                                }
                                else if (event.ctrlKey && event.key === 'g') {
                                        event.preventDefault();
                                        for (var i = 0; i < interactiveGuides.length; i++) {
                                                var guide = interactiveGuides[i];
                                                canvas.remove(guide.horizontalLine)
                                                canvas.remove(guide.verticalLine)
                                                canvas.remove(guide.intersectionCircle)
                                        }
                                        interactiveGuides = [];
                                        canvas.renderAll();
                                }
                                else if (event.altKey && event.key === 'a') {
                                        event.preventDefault()
                                        addPOLYLINE()
                                }
                                else if (event.altKey && event.key === 's') {
                                        event.preventDefault()
                                        addPOLYGON(20, 100, 100, 30)
                                }
                                else if (event.altKey && event.key === 'd') {
                                        event.preventDefault()
                                        addTEXT('roboto_b', 100, 100, 100, 'test')
                                }
                                else if (event.altKey && event.key === 'f') {
                                        event.preventDefault()
                                        addRECTinteractive()
                                }    
                                else if (event.altKey && event.key === 'g') {
                                        event.preventDefault()
                                        addELLIPSEinteractive()
                                }       
                        })


                        var wakeLock = null
                        async function requestWakeLock() {
                                try {
                                        wakeLock = await navigator.wakeLock.request("screen")
                                        console.log("Wake Lock attivato")
                                        wakeLock.addEventListener("release", () => {
                                                console.log("Wake Lock rilasciato")
                                        })
                                } catch (err) {
                                       console.error(`${err.name}, ${err.message}`)
                                }
                        }; requestWakeLock()

                        function isRunningAsPWA() {
                                return (
                                        window.matchMedia('(display-mode: standalone)').matches || 
                                        window.navigator.standalone === true                     
                                )
                        }
                        window.addEventListener("DOMContentLoaded", () => {
                                if (!isRunningAsPWA()) {
                                        document.getElementById("pwa-warning").style.display = "block"
                                }
                        })                                                 
                </script>                                 

                <div id="pwa-warning" style="
                        display:none; position:fixed; bottom:20px; left:50%; transform:translateX(-50%);
                        background:#000; border:1px solid #3c3c3c; padding:15px 20px; font-size:12px; z-index:9999;
                ">
                  ⚠️ for stable background execution, install the PWA from your browser.
                </div>
                                  
                <div id="splash" style="z-index:9999; position:absolute; width:100%; height:100%; left:50%; transform:translateX(-50%)">
                        <script>                                    

                                setTimeout(() => {
                                        $("#splash").load("../HTML/anim.html", function() {
                                                setTimeout(() => {
                                                        $("#splash").addClass("fade");
                                                        setTimeout(() => { $("#splash").remove(); }, 2000)
                                                }, 3000)
                                        })
                                        setTimeout(() => {setWorkArea(); TAOpen()}, 5000)
                                }, 0)

                        </script>   
                        
                </div>                
        </body>             
</html>  

<!--

-->

